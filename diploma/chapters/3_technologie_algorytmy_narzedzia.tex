\chapter{Narzędzia, architektura i implementacja}
\label{chap:algs}

\section{Narzędzia}

Silnik została napisany jako biblioteka w języku C w standardzie C11 \cite{C11REFERENCE}. Budowanie biblioteki ze źródeł wymaga generacji
dodatkowego kodu przy pomocy skryptów w języku Python w wersji 3.9.7 \cite{PYTHONREFERENCE}.

Silnik został w całości opracowany na przy użyciu środowiska programistycznego CLion w wersji 2021.2.3 \cite{CLION}.

Proces testowania i debugowania odbywał się na maszynie o następującej konfiguracji:
\begin{itemize}
	\item {OS}: Kubuntu 22.04.1 LTS x86-64,
	\item {CPU}: 11th Gen Intel Core i5-11400 (2.60GHz),
	\item {GPU}: Intel UHD Graphics 730 (Rocket Lake GT1).
\end{itemize}

Podczas pracy stosowano rozproszony system kontroli wersji git. Repozytorium jest utrzymywane na serwisie GitHub \cite{GITHUB}.

Pliki \textit{.clang-tidy} i \textit{.clang-format} znajdujące się w strukturze plików projektu pozwalają na automatyczne formatowanie kodu źródłowego zgodnie ze uprzednio zdefiniowanym standardem kodowania.

Proces budowania projektu jest zautomatyzowany przy użyciu narzędzia CMake \cite{CMAKE}, które w przypadku języków C i C++ jest praktycznie standardem podczas rozwoju wieloplatformowych projektów.

\subsection{Proces budowania}

Proces budowania silnika jest zdefiniowany w pliku *CMakeLists.txt* znajdującym się w katalogu głównym projektu.

Kompilacja kodu źródłowego w języku C jest obsługiwana bezpośrednio przez CMake, które generuje standardowe pliki
kompilacji (pliki Makefile w systemie Linux, projekty Microsoft Visual C++ w systemie Windows).
Silnik był napisany i przetestowany wyłącznie na systemie Linux, ale wieloplatformowa natura używanych narzędzi i bibliotek powinna pozwolić na dokonanie kompilacji skrośnej.
Użyto prekompilowanych nagłówków do przyśpieszenia kompilacji bibliotek zewnętrznych.

Skrypty w języku Python są obsługiwane pośrednio przez CMake, które wykrywa zainstalowany interpreter języka Python i
używa go do stworzenia tzw. środowiska wirtualnego w tymczasowym katalogu venv/ w głównym katalogu projektu. Podczas
procesu budowania środowisko wirtualne jest używane do zainstalowania wymaganych zewnętrznych bibliotek w języku Python
i wykonywania skryptów generatora kodu. Zaletą użycia środowiska wirtualnego w porównaniu do bezpośredniego wywoływania
zainstalowanego interpretera Pythona jest izolacja zarządzania zależnościami od reszty systemu operacyjnego, co pozwala
na łatwiejszą powtarzalność podczas debugowania \cite{PEP405}.

CMake organizuje proces budowania jako graf, w którym wierzchołki to cele połączonych ze sobą zależnościami. Budowa celu
wymaga wcześniejszego zbudowania wszystkich innych celów od których zależy budowany cel.

Wyróżniane są trzy rodzaje celów:
\begin{itemize}
	\item {plik wykonywalny};
	\item {biblioteka}: statyczna lub dynamiczna;
	\item {cel niestandardowy}: używany do uruchamiania zewnętrznych programów podczas procesu kompilacji, np. generatorów kodu.
\end{itemize}

Diagram \ref{cmake} przedstawia proces budowania projektu w formie celów i ich zależności.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=2cm]
		\tikzstyle{module} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node (main) [module] {main};
		\node (test) [module, right = of main] {test};
		\node (assetpipeline) [module, right = of test] {asset\_pipeline};
		
		\node (engine) [module, below = of main] {engine};
		
		\node (runassetpipeline) [module, above = of assetpipeline] {run\_asset\_pipeline};
		\node (copyasset) [module, left = of runassetpipeline] {copy\_asset};
		
		\draw [arrow] (main) -- (engine);
		\draw [arrow] (test) edge[out=180, in=45] (engine);
		\draw [arrow] (assetpipeline) edge[out=-90, in=0] (engine);
		
		\draw [arrow] (main) edge[]  (runassetpipeline);
		\draw [arrow] (test) edge[]  (runassetpipeline);
		
		\draw [arrow] (runassetpipeline) -- (assetpipeline);
		
		\draw [arrow] (main) -- (copyasset);
		\draw [arrow] (test) -- (copyasset);
		\draw [arrow] (assetpipeline) -- (copyasset);
		\draw [arrow] (runassetpipeline) -- (copyasset);
		
		\node(plikiwykonywalne)[draw,dotted,fit=(main) (test) (assetpipeline)] {};
		\node (plikiwykonywalneLabel)[below=0cm of plikiwykonywalne] {\textbf{Pliki wykonywalne}};
		
		\node(biblioteki)[draw,dotted,fit=(engine)] {};
		\node (bibliotekiLabel)[below=0cm of biblioteki] {\textbf{Biblioteki}};
		
		\node(celeniestandardowe)[draw,dotted,fit=(copyasset) (runassetpipeline)] {};
		\node (celeniestandardoweLabel)[above=0cm of celeniestandardowe] {\textbf{Cele niestandardowe}};
		
	\end{tikzpicture}
	\caption{Proces budowania w formie celów i ich zależności (opracowanie własne)}
	\label{cmake}
\end{figure}

\paragraph{engine} Cel budujący bibliotekę programistyczną zawierającą implementację silnika.

\paragraph{main} Cel budujący plik wykonywalny demonstujący użycie silnika poprzez wyrenderowanie przykładowej sceny.

\paragraph{test} Cel budujący plik wykonywalny z testami jednostkowymi napisanymi i używanymi podczas implementowania projektu.

\paragraph{asset\_pipeline} Cel budujący plik wykonywalny służący jako narzędzie wiersza poleceń wykonujące operacje potoku zasobów.

\paragraph{copy\_assets} Niestandardowy cel kopiujący podkatalogu głównego \textit{assets} zawierającego nieprzetworzone zasoby wejściowe do katalogu budowania.

\paragraph{run\_asset\_pipeline} Niestandardowy cel realizujący potoku zasobów poprzez uruchomienie skryptu Python wielokrotne uruchamiającego narzędzie \textbf{asset\_pipeline} na zasobach wejściowych.


\subsection{Biblioteki zewnętrzne}

Projekt używa następujących zewnętrznych bibliotek programistycznych:

\begin{itemize}
	\item {\textit{Vulkan SDK 1.3.211.0}} \cite{VULKANSDK}:
	\begin{itemize}
		\item pliki nagłówkowe dla Vulkan,
		\item \textit{shaderc}: kompilacja shaderów z kodu źródłowego GLSL do kodu bajtowego SPIR,
		\item \textit{SPIRV-Reflect}: mechanizm refleksji dla kodu bajtowego SPIR-V,
	\end{itemize}
	\item {\textit{glfw 3.4}} \cite{GLFW}: wieloplatformowa obsługa tworzenia okien, obsługa wejścia klawiatury i myszy,
	\item {\textit{sqlite 3.35.5}} \cite{SQLITE}: relacyjna baza danych SQL,
	\item {\textit{uthash 2.3.0}} \cite{UTHASH}: proste struktury danych (tablica dynamiczna, lista dwukierunkowa, tablica mieszająca),
	\item {\textit{xxHash 0.8.1}} \cite{XXHASH}: niekryptograficzny algorytm mieszający,
	\item {\textit{cgltf 1.11}} \cite{CGLTF}: wczytywanie plików w formacie glTF,
	\item {\textit{cglm 0.8.5}} \cite{CGLM}: biblioteka matematyczna,
	\item {\textit{stb\_image 2.27}} \cite{STB}: wczytywanie obrazów,
	\item {\textit{stb\_truetype 1.26}} \cite{STB}: rasteryzacja tekstu czcionek,
	\item {biblioteka standardowa języka C} \cite{C11REFERENCE},
	\item {API systemu operacyjnego}: pliki nagłówkowe POSIX \cite{POSIXREFERENCE} albo WinAPI \cite{WINAPIREFERENCE},
	\item {biblioteka standardowa języka Python \cite{PYTHONREFERENCE}},
	\item {\textit{libclang 12.0.0}} \cite{LIBCLANG}: analizowanie kodu C w skryptach Python.
\end{itemize}

Dodatkowo biblioteka zbudowana w konfiguracji \textit{Debug} statycznie linkuje biblioteki \textit{ASan} (AddressSanitizer) i \textit{UBSan} (
UndefinedBehaviorSanitizer) wykrywające szeroką klasę błędów dotyczących niewłaściwego użycia pamięci i niezdefiniowanych zachowań. Błędy te w języku C są nieoczywiste i trudne do wykrycia przez programistę. Podczas rozwoju projektu ASan wielokrotnie pozwolił na wykrycie i naprawienie następujących rodzajów błędów:

\begin{itemize}
	\item wycieki pamięci,
	\item dereferencje zwisających wskaźników,
	\item dereferencja wskaźników NULL,
	\item dereferencja źle wyrównanych struktur,
	\item odczyt i zapis poza granicami tablicy.
\end{itemize}

\section{Architektura}

Silnik jest zaprojektowany w duchu architektury modułowej - funkcjonalność biblioteki jest rozdzielona na bloki zwane modułami, które mogą być rozwijane niezależnie od pozostałych modułów.

Obecne silnik składa się z następujących modułów:
\begin{itemize}
	\item Wygenerowany kod: mechanizmy metaprogramowania;
	\item Rdzeń: funkcje pomocnicze;
	\item I/O: wczytywanie bazy zasobów i konfiguracji;
	\item Zasoby: serializacja i deserializacja danych sceny z bazy zasobów;
	\item Vulkan: obsługa API Vulkan;
	\item Scena: operacje na grafie sceny;
	\item Renderer: graf renderowania i główna pętla programu.
\end{itemize}
Dodatkowo budowany jest plik wykonywalny demonstujący użycie silnika do wyrenderowanie przykładowej sceny używając grafu renderowania odroczonego.

Silnik był rozwijany metodą \textit{bottom-up} - jego pierwsza iteracja była pojedynczym plikiem źródłowym wyświetlającym trójkąt \cite{VULKANTUTORIAL}, który w procesie dekompozycji i refaktoryzacji organicznie rozrósł się do 7 modułów znajdujących się w osobnych podkatalogach zawierających łącznie 9 skryptów Python \textit{.py}, 65 nagłówków \textit{*.h} i 63 plików źródłowych \textit{*.c}.

Moduł jest dalej podzielony na jednostki, które zostały na potrzeby projektu zdefiniowane jako para składająca się z pliku nagłówkowego z odpowiadającym plikiem źródłowymi o tej samej nazwie.

Pliki nagłówkowe zawierają deklaracje funkcji, struktur oraz typów wyliczeniowych widocznych dla użytkownika końcowego i powinny być dołączone do programu przy użyciu dyrektywy \textit{\#include} preprocesora.
Pliki źródłowe zawierają definicje deklaracji plika nagłówkowego i powinny być dołączone do programu używając argumentów kompilatora (jeśli dodawane są niezbudowane pliki źródłowe) bądź linkera (jeśli dodawane są zbudowane pliki biblioteczne), co jest automatycznie wykonywane przez CMake.

Struktury są zorganizowane w sposób obiektowy.
Język C nie posiada wbudowanej koncepcji klasy, ale w projekcie przyjęto założenie, że dla klasy \textit{struct} jej stan jest reprezentowany przez strukturę \textit{struct}, która może posiadać metodę \textit{func()}, jeśli istnieje funkcja \textit{struct\_func()} przyjmująca wskaźnik do \textit{struct} jako pierwszy argument.
Dla obiektów globalnych nie jest istnieje osobna struktura przekazywana do jej metod - stan obiektu jest zaszyty w zmiennych globalnych jednostki translacji pliku źródłowego.

Obiekty mogą oferować metody \textit{create()} i \textit{destroy()}, które alokują lub dealokują instancję obiektu oraz tworzą bądź niszczą jej wewnętrzny stan.
Analogiczne metody \textit{init()} i \textit{deinit()} tworzą i niszczą instancję, której pamięć została wcześniej zaalokowaną (np. na stosie lub w tablicy).
Opcjonalna metoda \textit{debug\_print()} loguje informacje o wewnętrznym stanie instancji użyteczne podczas debugowania.

Diagram \ref{archit} przedstawia moduły silnika i ich najważniejsze jednostki.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=2mm]
		\tikzstyle{class} = [rectangle, minimum width=2cm, minimum height=5mm,text centered, draw=black]
		\tikzstyle{file} = [rectangle, minimum width=2cm, minimum height=5mm,text centered, draw=gray]
		\tikzstyle{file2} = [file, minimum width=3cm]
		\tikzstyle{executable} = [rectangle, rounded corners, minimum width=1cm, minimum height=5mm,text centered, draw=gray]

		\tikzstyle{arrow} = [thick,->,>=stealth]
		\tikzstyle{relation} = [densely dotted]
		
		% codegen
		\node (descriptors) [file] {descriptors};
		\node (constants) [file, below = of descriptors] {constants};
		\node (globals) [file, below = of constants] {globals};
		\node (macros) [file, below = of globals] {macros};
		\node (meta) [file, below = of macros] {meta};
		\node(codegen)[draw,dotted,fit=(descriptors) (meta)] {};
		
		% core
		\node (alloc) [file, below = 1cm of codegen] {alloc};
		\node (junk) [file, below = of alloc] {junk};
		\node (log) [file, below = of junk] {log};
		\node (platform) [file, below = of log] {platform};
		\node (thirdparty) [file, below = of platform] {thirdparty};
		\node(core)[draw,dotted,fit=(alloc) (junk) (log) (platform) (thirdparty)] {};
		
		% data
		\node (db) [file, below = 1cm of core] {sql\_db};
		\node (config) [file, below = of db] {config};
		\node (assetdb) [file, below = of config] {asset\_db};
		\node(data)[draw,dotted,fit=(db) (assetdb)] {};
		
		% assets
		\node (assetcommon) [file2, right = 2cm of platform] {asset\_common}; \def\y{assetcommon};
		\def\x{asset_camera}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_direct_light}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_material}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_vertex_attribute}; \node (\x) [file2, right = of assetcommon] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_primitive}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_mesh}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_object}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_image}; \node (\x) [file2, right = of asset_vertex_attribute] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_sampler}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_texture}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_skybox}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_font}; \node (\x) [file2, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\node (assetpipeline) [executable, below = of asset_object] {asset\_pipeline};
		\node(assets)[draw,dotted,fit=(assetcommon) (asset_font)] {};
	
		% scene
		\node (scene_data) [file, right = 3.6cm of junk] {scene\_data}; \def\y{scene_data};
		\def\x{scene_graph}; \node (\x) [file, right = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{scene_tree}; \node (\x) [file, right = of \y] {\myesc{\x}}; \edef\y{\x};
		\node(scene)[draw,dotted,fit=(scene_data) (scene_tree)] {};
		
		% vulkan
		\node (buffer) [file, right = 1.5cm of descriptors] {buffer}; \def\y{buffer};
		\def\x{image}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{vertex_stream};\node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{device}; \node (\x) [file, right = 1cm of buffer] {\myesc{\x}}; \edef\y{\x};
		\def\x{swap_chain}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{sync}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{unified_constant_buffer}; \node (\x) [file, below = 4mm of vertex_stream] {\myesc{\x}}; \edef\y{\x};
		\def\x{textures}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{unified_geometry_buffer}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{descriptor};\node (\x) [file, right = 1mm of unified_constant_buffer] {\myesc{\x}}; \edef\y{\x};
		\def\x{shader};\node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\node(objects)[draw,dotted,fit=(device) (unified_geometry_buffer) (shader)] {};
		
		% renderer
		\node (renderer) [file, right = 7mm of device] {renderer}; \def\y{renderer};
		\def\x{render_state}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{renderer_cache}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{render_graph}; \node (\x) [file, right = of render_state] {\myesc{\x}}; \edef\y{\x};
		\def\x{render_pass}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{render_pass_state}; \node (\x) [file, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{batch}; \node (\x) [file, left = of render_pass_state] {\myesc{\x}}; \edef\y{\x};
		\def\x{main}; \node (\x) [executable, right = 0.7cm of renderer] {\myesc{\x}}; \edef\y{\x};
		\node(rendering)[draw,dotted,fit=(renderer) (renderer_cache) (render_pass_state) (main) (batch)] {};
	
		% labels
		\node ()[above=0cm of codegen] {\textbf{Wygenerowany kod}};
		\node ()[above=0cm of core] {\textbf{Rdzeń}};
		\node ()[above=0cm of data] {\textbf{I/O}};
		\node ()[below=0cm of assets] {\textbf{Zasoby}};
		\node ()[above=0cm of objects] {\textbf{Vulkan}};
		\node ()[below=0cm of scene] {\textbf{Scena}};
		\node ()[above=0cm of rendering] {\textbf{Renderer}};
		
	\end{tikzpicture}
	\caption{Relacje pomiędzy modułam silnika i ich najważniejszymi klasami (opracowanie własne)}
	\label{archit}
\end{figure}

\section {Implementacja}

Ta sekcja opisuje szczegóły implementacyjne poszczególnych modułów silnika.

\subsection{Wygenerowany kod}

Silnik używa kodu w języku C wygenerowanego przez automatyczny generator kodu będący skryptem Python uruchamianym przez CMake na początku procesu budowania przed rozpoczęciem kompilacji właściwego
kodu źródłowego biblioteki.

Język C nie posiada mechanizmów pozwalających na metaprogramowanie z wyjątkiem makr preprocesora, które mogą zaspokoić część potrzeb programisty chcącego przykładowo dodać nowy rodzaje pętli \cite{METACONTROLC}, ale nie pozwalają na bardziej skomplikowaną analizę i przekształcanie kodu, które muszą być wykonywane przez zewnętrzne narzędzia.

Działanie skryptu jest sterowane konfiguracją generatora, który jest plikiem w formacie INI (zgodnym z biblioteką \textit{configparser} \cite{PYTHONCONFIGPARSER}) znajdującym się w katalogu ze skryptem.
Format INI nie posiada standardowej specyfikacji, ale tradycyjnie jest on plikiem tekstowym podzielonym na sekcje zawierające pary klucz-wartość.

Skrypt parsuje pliki nagłówkowe języka C znajdujący się w katalogu /src z
pominięciem katalogu /src/codegen, do którego skrypt zapisuje wygenerowane pliki nagłówkowe i źródłowe, które są kolejno dołączane w innych modułach silnika i dodawane jako argumenty kompilatora.
Razem wszystkie wygenerowane pliki tworzą jednostki modułu wygenerowanego kodu.


\subsubsection{Jednostka constants}
Zawiera wygenerowane stałe: wartości zdefiniowane w sekcji \textit{CONSTANTS} konfiguracji generatora używane przez resztę modułów, które zostały uznane za zbyt niepraktyczne aby pozwolić na ich modyfikację przy użyciu konfiguracji globalnej.
Poniżej wymieniono stałe, ich wartości oraz interpretacje:
\begin{itemize}
	\item \textit{FRAMES\_IN\_FLIGHT}: $2$, liczba klatek w locie (ang. in flight frames), czyli jednocześnie renderowanych przez GPU, domyślna wartość pozwala na podwójne buforowanie; 
	\item \textit{MAX\_OFFSCREEN\_TEXTURE\_COUNT}: $16$, maksymalna liczbę tekstur pozaekranowych;
	\item \textit{MAX\_RENDER\_TARGET\_COUNT}: $8$, maksymalną liczbę tekstur pozaekranowych, które mogą być używane jako cele renderowania podczas jednego przebiegu; 
	\item \textit{MAX\_FRAMEBUFFER\_ATTACHMENT\_COUNT}: \textit{MAX\_RENDER\_TARGET\_COUNT + 1 + 1}, maksymalna liczba dołączeń używana przez potok graficzny - wystarcza na dołączenia celów renderowania, prezentowalnego obrazu i bufor głębi;
	\item \textit{MAX\_INDIRECT\_DRAW\_COMMAND\_COUNT}: $1024$, maksymalna liczba poleceń rysowania które mogą być wykonana przez jedno polecenie rysowania pośredniego;
	\item \textit{MAX\_MATERIAL\_COUNT}: $128$, maksymalna liczba materiałów;
	\item \textit{MAX\_DIRECTIONAL\_LIGHT\_COUNT}: $1$, maksymalna liczbę świateł kierunkowych na scenie;
	\item \textit{MAX\_POINT\_LIGHT\_COUNT}: $128$, maksymalna liczbę świateł punktowych na scenie;
	\item \textit{MAX\_TEXT\_CHARACTER\_COUNT}: $256$, maksymalną liczbę znaków w renderowanym ciągu znaków;
	\item \textit{MIN\_DELTA\_TIME}: $(1.0 / 30.0)$, minimalny czas pomiędzy wywołaniami funkcji zwrotnej \textit{update} w pętli głównej, domyślnie $\frac{1}{30}$ sekundy (30 FPS);
	\item \textit{WORLD\_UP}: $0, 1, 0$; wektor interpretowany jako "w górę" w przestrzeni świata.
\end{itemize}

Wygenerowane stałe mogą być używane przez shadery - ich definicje są umieszczane na początku kodu GLSL shadera przed jego kompilacją - dlatego są one udostępniane w formie X-makro \textit{CODEGEN\_CONSTANTS}.

X-makro to przydatna technika preprocesora pozwalająca na pisanie kodu, który jest automatycznie aktualizowany po zmianie danych opisywanych przez X-makro \cite{XMACRO}.
Przykładowo funkcja przedstawiona na listingu \ref{xmacroBefore} wymaga manualnej aktualizacji po zmianie używanego typu wyliczeniowego.
\lstset{language=C}
\begin{lstlisting}[caption={Przykładowy kod przed zastosowaniem X-makro},captionpos=b,label={xmacroBefore}]
typedef enum key {
	key_space,
	key_enter,
	key_count,
} key;

int key_to_glfw_key(key value) {
	switch (value) {
		case key_space: return GLFW_KEY_SPACE;
		case key_enter: return GLFW_KEY_ENTER;
		default: return GLFW_KEY_UNKNOWN;
	}
}
\end{lstlisting}
Listing \ref{xmacroAfter} przedstawia użycie X-makro do przepisania kodu z listingu \ref{xmacroBefore}:
\lstset{language=C}
\begin{lstlisting}[caption={Przykładowy kod po zastosowaniu X-makro},captionpos=b,label={xmacroAfter}]

#define END_OF_KEYS
#define KEYS(X, ...)			\
	X(space, GLFW_KEY_SPACE)	\
	X(enter, GLFW_KEY_ENTER)	\
	END_OF_KEYS

typedef enum key {
#define x(_name, ...) key_##_name,
	KEYS(x, )
#undef x
	key_count,
} key;

int key_to_glfw_key(key value) {
	switch (value) {
#define x(_name, _value, ...) case key_##_name: return _value;
		KEYS(x, )
#undef x
		default: return GLFW_KEY_UNKNOWN;
	}
}
\end{lstlisting}


\subsubsection{Jednostka globals}
Obiekt globalny \textit{globals} reprezentujący wygenerowane zmienne.
Ich wartości, w przeciwieństwie do stałych, mogą być ustalone dopiero w czasie wykonywania.
Obiekt jest używany do specyfikacji struktury różnych ścieżek katalogów i plików używanych przez silnik.

Listing \ref{configGenBefore} przedstawią sekcję konfiguracji generacji opisującą ścieżki dla katalogu zasobów, konfiguracji globalnej, bazy zasobów, katalogu shaderów i ich współdzielonego kodu GLSL oraz pliku logowania.
\lstset{language=verbatim}
\begin{lstlisting}[caption={Konfiguracja generacji zmiennych},captionpos=b,label={configGenBefore}]
[GLOBALS]
assetsDirname = assets
assetDatabaseFilepath = ${assetsDirname}/data.db
assetConfigFilepath = ${assetsDirname}/config.ini
assetsShaderDirpath = ${assetsDirname}/shaders
assetsShaderCommonFilepath = ${assetsShaderDirpath}/common.glsl
logFileName = log.txt
\end{lstlisting}
Listing \ref{configGenAfter} przedstawia wygenerowaną metodę \textit{init()}.
\lstset{language=C}
\begin{lstlisting}[caption={Wynik generacji zmiennych},captionpos=b,label={configGenAfter}]
void globals_create() {
	globals.assetsDirname =
		get_executable_dir_file_path("", "assets");
	globals.assetDatabaseFilepath =
		get_executable_dir_file_path("", "assets/data.db");
	globals.assetConfigFilepath =
		get_executable_dir_file_path("", "assets/config.ini");
	globals.assetsShaderDirpath =
		get_executable_dir_file_path("", "assets/shaders");
	globals.assetsShaderCommonFilepath =
  		get_executable_dir_file_path("", "assets/shaders/common.glsl");
	globals.logFileName =
		get_executable_dir_file_path("", "log.txt");
}
\end{lstlisting}

\subsubsection{Jednostka macros}
Zbiór X-makr używanych przez moduł I/O obsługujący następujące zasoby wejściowe.

Makra opisują wewnętrzną strukturę plików INI konfiguracji globalnej i konfiguracji zasobów: używane sekcje i ich dopuszczalne pary klucz-wartość z domyślnymi wartościami (liczby całkowite bądź ciągi znaków).
Listing \ref{macrosBefore} przedstawia przykładowy fragment konfiguracji generatora opisujący konfigurację globalną i pozwalający na sparsowanie pliku INI przedstawionego na listingu \ref{macrosAfter}.
\lstset{language=verbatim}
\begin{lstlisting}[caption={Konfiguracja generacji konfiguracji globalnej},captionpos=b,label={macrosBefore}]
[GLOBAL.CONFIG]
graphics.WindowWidth = 640
controls.Enabled = 1
settings.StartScene = "sponza"
\end{lstlisting}

\lstset{language=verbatim}
\begin{lstlisting}[caption={Przykładowa konfiguracja globalna},captionpos=b,label={macrosAfter}]
[settings]
StartScene = MetalRoughSpheresNoTextures

[graphics]
WindowWidth = 1024

[controls]
Enabled = 1 
\end{lstlisting}

Podobnie opisywana jest struktura bazy zasobów: typy podstawowe i ich odpowiedniki w języku C oraz tabele i ich kolumny. Ilustruje to fragment konfiguracji generatora przedstawiony na listingu \ref{macrosDB}.
\lstset{language=verbatim}
\begin{lstlisting}[caption={Fragment konfiguracji generatora opisujący strukturę bazy zasobów},captionpos=b,label={macrosDB}]
[ASSET.DB]
types = "BYTE:uint8_t, INT:uint32_t, FLOAT:float, TEXT:UT_string *, KEY:hash_t"
image = "key KEY, width INT, height INT, depth INT, channels INT, type INT, data BYTE_ARRAY"
sampler = "key KEY, magFilter INT, minFilter INT, addressWrapU INT, addressWrapV INT"
texture = "key KEY, image KEY, sampler KEY"
\end{lstlisting}

Struktura zasobów wejściowych zostanie dokładniej opisana w dalszym podrozdziale o module I/O.

\subsubsection{Jednostka meta}
Funkcje pomocnicze wygenerowane na podstawie nagłówków silnika i Vulkan SDK.

Dla każdego napotkanego typu wyliczeniowego \textit{EnumName} jest generowana jedna z funkcji, których prototypy zostały przedstawione na listingu \ref{metaProtos}.
\lstset{language=C}
\begin{lstlisting}[caption={Wygenerowane funkcje dla typów wyliczeniowych},captionpos=b,label={metaProtos}]
const char *EnumName_debug_str(int value);
void EnumName_debug_print(int flags, int indent);
\end{lstlisting}
Funkcje pozwalające na konwersję liczby całkowitej będącej wartoścą zmiennej wyliczeniowego na ciąg znaków i są używane przez metody \textit{debug\_print()} do logowania wartości w formie przyjaźniejszej dla użytkownika.

Funkcja \textit{*\_debug\_str()} jest generowana tylko wtedy, jeśli literały wyliczeniowe nie są flagami, tj. nie są kolejnymi potęgami liczby 2.


\subsubsection{Jednostka descriptors}
Jednostka zawierająca struktury i funkcje upraszczające pracę z deskryptorami.

Nagłówek \textit{descriptor} modułu Vulkan zawiera definicje struktur języka C opisujących wewnętrzną strukturę pamięci buforów i stałych push znajdujących się na GPU.
W zależności od nazwy dzielą się one na 3 rodziny:
\begin{itemize}
	\item \textit{*\_push\_constant\_struct}: stała push o nazwie \textit{*},
	\item \textit{*\_uniform\_buffer\_struct}: bufor uniform o nazwie \textit{*},
	\item \textit{*\_helper\_struct}: struktura pomocnicza o nazwie \textit{*} używana w powyższych.
\end{itemize}
Listing \ref{descriptorsBefore} przedstawia przykłady powyższych struktur.
\lstset{language=C}
\begin{lstlisting}[caption={Przykładowe struktury w nagłówku descriptor opisujące wewnętrzną strukturę deskryptorów},captionpos=b,label={descriptorsBefore}]
// stała push 'draw'
typedef struct draw_push_constant_struct {
	uint currentFrameInFlight;
} draw_push_constant_struct;

// struktura pomocnicza 'offscreen_texture'
typedef struct offscreen_texture_helper_struct {
	uint textureId; ///< array=MAX_OFFSCREEN_TEXTURE_COUNT
} offscreen_texture_helper_struct;

// stała push 'global'
typedef struct global_uniform_buffer_struct {
	mat4 viewMat;
	mat4 projMat;
	...
	offscreen_texture_helper_struct offscreenTextures;
} global_uniform_buffer_struct;
\end{lstlisting}

Układ pamięci struktur zdefiniowanych w języku C nie jest koniecznie kompatybilny z układem pamięci wymaganym przez GPU.
Dlatego dla każdej sparsowanej struktury \textit{*\_struct} jest generowana analogiczna struktura \textit{*\_element}, w których użyto specyfikatorów \textit{alignas} i atrybutów \textit{packed} udostępnianych przez C11 i rozszerzenia GCC w celu wyrównania pól struktury w zgodzie ze standardem układu pamięci scalar.
Generowana jest też funkcja \textit{glsl\_add\_*()} dodająca do ciągu znaków z kodem GLSL definicje struktury i kwalifikator układu.
Listing \ref{descriptorsAfter} pokazuje przykładowe wejście i wyjście generacji dla bufora uniform \textit{instances}.
\lstset{language=C}
\begin{lstlisting}[caption={Przykładowe wejście i wyjście generacji dla bufora uniform},captionpos=b,label={descriptorsAfter}]
// descriptor.h:
typedef struct instances_uniform_buffer_struct {
	mat4 modelMat;
	uint materialId;
} instances_uniform_buffer_struct;
	
// descriptors.h
typedef struct PACKED_STRUCT instances_uniform_buffer_element {
	alignas(4) mat4 modelMat ;
	alignas(4) uint materialId ;
} instances_uniform_buffer_element;
void glsl_add_instances_uniform_buffer(
	UT_string *s, uint32_t set, uint32_t binding, uint32_t count);

// descriptors.c
void glsl_add_instances_uniform_buffer(
	UT_string *s, uint32_t set, uint32_t binding, uint32_t count) {
	utstring_printf(s, "struct instancesStruct {\n");
	utstring_printf(s, "  mat4 modelMat ;\n");
	utstring_printf(s, "  uint materialId ;\n");
	utstring_printf(s, "};\n");
	utstring_printf(s, "layout(scalar, set = %u, binding = %u) "
			   "uniform instancesBlock {\n", set, binding);
	utstring_printf(s, "  instancesStruct instances");
	if (count > 1) {utstring_printf(s, "[%u]", count);}
	utstring_printf(s, ";\n};\n");
}
\end{lstlisting}
Generacja jest kończona X-makrami wyliczającymi nazwy wszystkich sparsowanych rodzin struktur. 

Dzięki automatycznej generacji kodu modyfikacja sposobu organizacji pamięci GPU buforów sprowadza się do modyfikacji struktur w nagłówku \textit{descriptors}, co pozwala na szybkie testowanie nowych parametrów i metod dostępu do nich podczas pisania shaderów.
Mechanizm ten został zainspirowany implementacją jednolitych buforów w grze \textit{Tom Clancy's Rainbow Six Siege} \cite{RAINBOWSIXSIEGE}.

Wygenerowane struktury, funkcje i X-makra są używane podczas kopiowania danych z CPU do pamięci GPU oraz generacji shaderów, co zostanie dokładniej opisane w dalszym podrozdziale o module Vulkan.

\subsection{Rdzeń}

Rdzeń to moduł zawierający funkcje pomocniczych i obiekty globalne zapewniające podstawowe funkcjonalności używane przez resztę modułów.

\subsubsection{Jednostka thirdparty}
Jednostka odpowiedzialna za udostępnienia bibliotek zewnętrznych reszcie kodu.

Nagłówek dołącza nagłówki bibliotek zewnętrznych i z powodów wydajnościowych podczas procesu budowania jest traktowany jako nagłówek prekompilowany (ang. precompiled header, PCH).

Plik źródłowy obsługuje część bibliotek zewnętrznych składających się jedynie z nagłówków (ang. header-only library).
W przeciwieństwie do tradycyjnych bibliotek języka C w których kod jest podzielony na pliki nagłówkowe i źródłowe, w tym przypadku dostęp do definicji tradycyjnie znajdujących się z plikach źródłowych jest uzyskiwany poprzez ponowne dołączenie nagłówka przy użyciu dyrektywy \textit{\#include} po wcześniejszym zdefiniowaniu odpowiedniego symbolu preprocesora.
Listing \ref{thirdpartyCgltf} przedstawia wymagany sposób ponownego dołączenia nagłówka biblioteki \textit{cgltf}.
\lstset{language=C}
\begin{lstlisting}[caption={Przykład dołączenia implementacji biblioteki \textit{cgltf}},captionpos=b,label={thirdpartyCgltf}]
#define CGLTF_IMPLEMENTATION
#include "cgltf.h"
\end{lstlisting}

\subsubsection{Jednostka alloc}
Funkcje pomocnicze wspomagające zarządzanie pamięcią CPU, co obejmuje alokację, dealokację, kopiowanie, duplikowanie i porównywanie bloków pamięci CPU.

Funkcje te są potrzebne, ponieważ działanie odpowiednich funkcji oferowane przez bibliotekę standardową języka C, chociaż oferują żądaną funkcjonalność, opiera się na mechanizmie niezdefiniowanych zachowań (ang. undefined behaviour) dla niektórych argumentów (wskaźnik NULL, rozmiar 0) i zachowań OOM (ang. out-of-memory, brak pamięci).

Funkcje pomocnicze są wrapperami z dodatkowymi instrukcjami warunkowymi sprawdzającymi, czy wywołanie funkcji nie skutkuje niezdefiniowanym zachowaniem.

Jednostka definiuje też makra ułatwiające zarządzanie pamięcią struktur danych biblioteki \textit{uthash}.


\subsubsection{Jednostka log}
Obiekt globalny \textit{log} reprezentujący system logowana komunikatów wygenerowanych podczas działania kodu mający na celu w uproszczenie procesu debugowania.

Komunikat jest ciągiem znaków z przypisanym poziomem logowania określającym jego ważność z domyślnie wspieranymi wartościami \textit{debug}, \textit{info}, \textit{warn}, \textit{error} i \textit{fatal}.
Komunikaty \textit{debug} są logowane tylko w konfiguracji \textit{Debug}.

Komunikaty są zapisywane do standardowego wyjścia (\textit{stdout} albo \textit{stderr}) oraz do pliku tekstowego na dysku, którego nazwa została zdefiniowana w wygenerowanych zmiennych (domyślnie \textit{log.txt}).

Logowanie komunikatu odbywa się poprzez grupę funkcji \textit{log\_*()}, gdzie \textit{*} to poziom logowania, zachowujące się tak samo jak funkcja \textit{printf()} z biblioteki standardowej języka C - pierwszy argument to ciąg znaków z znakami formatującymi, reszta argumentów to formatowane wartości.

Listing \ref{logBefore} demonstruje logowanie i powinien zapisać do pliku \textit{log.txt} w katalogu z plikiem wykonywalnym komunikaty podobne do przedstawionych na listingu \ref{logAfter}:
\lstset{language=C}
\begin{lstlisting}[caption={Demonstracja logowania},captionpos=b,label={logBefore}]
log_create();
log_debug("komunikat #%d", 1);
log_debug("komunikat #%d", 2);
log_fatal("%s #%d", "komunikat", 3);
log_destroy();
\end{lstlisting}

\lstset{language=verbatim}
\begin{lstlisting}[caption={Wynik logowania},captionpos=b,label={logAfter}]
[DEBUG] (/home/user/repo/src/main.c:45) main:
komunikat #1
komunikat #2
[FATAL] (/home/user/repo/src/main.c:47) main:
komunikat #3
\end{lstlisting}

\subsubsection{Jednostka junk}
Proste funkcje i makra które mogą być potencjalnie używane we wszystkich modułach biblioteki, ale nie zostały uznane za wystarczająca skomplikowane, aby uzasadnić wydzielenia do osobnej jednostki.

Jednostka definiuje stałe preprocesora \textit{PLATFORM\_*} przedstawione na listingu \ref{junk1} używane do rozpoznania systemu operacyjnego, na którym budowany jest silnik (Linux, MacOS, Windows).
\lstset{language=C}
\begin{lstlisting}[caption={Stałe preprocesora używane do rozpoznania systemu operacyjnego},captionpos=b,label={junk1}]
#if defined(__linux) || defined(__linux__) || defined(linux)
#define PLATFORM_LINUX
#elif defined(__APPLE__)
#define PLATFORM_APPLE
#elif defined(_WIN32) || defined(__WIN32__) \
   || defined(WIN32) || defined(_WIN64)
#define PLATFORM_WINDOWS
#endif
\end{lstlisting}

Funkcja \textit{strstrip()} usuwa początkowe i końcowe białe znaki z ciągu znaków.

Funkcja \textit{count\_bits()} zlicza bity w liczbie całkowitej używając metody Briana Kernighana \cite{BITTWIDDLINGHACKS}. Przykładem użycia jest określenie liczby flag ustawionych w wyliczeniu.

Makra \textit{HASH\_*} ukrywają detale użycie funkcji skrótu biblioteki \textit{xxHash} i zostały przedstawione na listingu \ref{junk2}.
\lstset{language=C}
\begin{lstlisting}[caption={Przykład użycia funkcji skrótu},captionpos=b,label={junk2}]
hash_t hash;
HASH_START(hashState)
HASH_UPDATE(hashState, &num, sizeof(num))
HASH_UPDATE(hashState, str, strlen(str))
HASH_UPDATE(hashState, &object->field, sizeof(object->field))
HASH_DIGEST(hashState, hash)
HASH_END(hashState)
log_debug("Hash value is %zu", hash);
\end{lstlisting}

Makro \textit{UNREACHABLE} pozwala na optymalizację kodu poprzez oznaczenie punktów programu, które nigdy nie są napotykane przez przepływ sterowania.
Jego definicja zależy od konfiguracji: w \textit{Debug} sprowadza się do asercji \textit{assert(0)}, a w \textit{Release} do funkcji wbudowanej kompilatora GCC \textit{\_\_builtin\_unreachable()}.
Przykładowo określenie nieosiągalności przypadku domyślnej instrukcji switch bądź bloku else informuje o
kompletności sprawdzanych warunków, co zostało przedstawione na listingu \ref{junk3}.
\lstset{language=C}
\begin{lstlisting}[caption={Przykład użycia makra UNREACHABLE},captionpos=b,label={junk3}]
if (type == directional) {
	...
} else if (type == point) {
	...
} else {
	UNREACHABLE;
}
\end{lstlisting}

Jednostka definiuje też makra używające formy metaprogramowania w celu dodania nowych struktur kontrolnych \cite{METACONTROLC} upraszczających iterowanie po strukturach danych biblioteki \textit{uthash}, której użycie zostało przedstawione na listingu \ref{junk4}.
\lstset{language=C}
\begin{lstlisting}[caption={Przykład iteracji używając makra utarray\_foreach\_elem\_deref},captionpos=b,label={junk4}]
utarray_foreach_elem_deref (tree_node *, node, tree->nodes) {
	tree_set_dirty(tree, node);
}
\end{lstlisting}


\subsubsection{Jednostka platform}
Głowna część rdzenia implementująca obiekt globalny \textit{platform} odpowiedzialny za tworzenie i niszczenie globalnego stanu używanego przez system logowania i funkcje wieloplatformowe, z których najważniejsze zostały opisane poniżej.

Funkcja \textit{panic()} pozwala na zamknięcie programu z kodem wyjścia oznaczającym nieudane wykonanie po wystąpieniu fatalnego błędu.
Jest ona używana przez makro \textit{verify()}, które podobnie do makra \textit{assert()} pozwala na testowanie warunku logicznego i przerwanie działania programu gdy przyjmuje on wartość fałsz, ale w przeciwieństwie do niego działa też w konfiguracji \textit{Release}.

Funkcje \textit{get\_executable\_dir\_path()} i \textit{get\_path\_dirname()} pozwalają na odkrycie ścieżki z katalogiem zawierającym plik wykonywalny, co jest potrzebne do pełnego określenia struktury plików opisanych przez wygenerowane stałe.
Na systemie Linux używana jest funkcja \textit{readlink()} do odczytania pliku \textit{/proc/self/exe}
oraz funkcja \textit{dirname()}.
Na systemie Windows używana jest funkcja \textit{GetModuleFileName()} oraz funkcja \textit{PathRemoveFileSpec()}.

Funkcje \textit{write\_text\_file()} i \textit{read\_text\_file()} pozwalają na odczyt i zapis plików tekstowych i są używane do obsługi konfiguracji i kodu źródłowego shaderów.

\subsection{I/O}

Silnik wczytuje ze ścieżek zaszytych w zmiennych globalnych następujące zasoby wyjściowe:
\begin{itemize}
	\item konfiguracja globalna (plik tekstowy INI),
	\item kod GLSL shadera (plik tekstowy GLSL),
	\item baza zasobów (baza danych).
\end{itemize}

Wszystkie zasoby wejściowe które muszą być łatwo edytowalne przez użytkownika są plikami tekstowymi i są bezpośrednio kopiowane przez potok zasobów do katalogu budowania stając się zasobami wyjściowymi.
Reszta zasobów wejściowych staje się częścią bazy zasobów będącej plikiem bazy danych SQLite.

SQLite \cite{SQLITE} to biblioteka języka C implementująca silnik relacyjnej bazy danych SQL.
Jest ona bardzo popularnym wyborem jako format pliku używany do utrwalania stanu aplikacji na dysku z wielu powodów, do których zalicza się prosta użycia, wysoka wydajności, bogata wewnętrzna struktura oferowana przez relacyjną bazę danych i formę łatwego do dystrybucji pojedynczego samodzielnego pliku na dysku \cite{SQLITEAPPFORMAT}.

Moduł I/O zawiera obiekty używane do wczytywania i zapisywania powyższych zasobów wraz z walidacją ich formatu i wewnętrznej struktury - interpretacją danych zajmują się dalsze moduły.

\subsubsection{Jednostka config}
Obiekt \textit{data\_config} reprezentujący pojedynczy plik INI zawierający jeden z dwóch rodzajów konfiguracji: konfigurację globalną lub konfigurację zasobów.

\textbf{Konfiguracja globalna} jest ładowana na samym początku inicjalizacji silnika i pozwala użytkownikowi na sterowanie jego działania poprzez zmianę następujących zmiennych:
\begin{itemize}
	\item sekcja \textit{graphics}:
	\begin{itemize}
		\item \textit{WindowWidth}, \textit{WindowHeight}, \textit{WindowTitle}: szerokość, wysokość i tytuł okna,
		\item \textit{EnabledInstancing}: włączenie instancjonowania,
		\item \textit{MaxPrimitiveElementCount}: maksymalna liczba prymitywów renderowania,
		\item \textit{Font}: czcionka,
	\end{itemize}
	\item sekcja \textit{controls}:
	\begin{itemize}
		\item \textit{Enabled}: obsługa danych wejściowych myszy i klawiatury,
	\end{itemize}
	\item sekcja \textit{settings}:
	\begin{itemize}
		\item \textit{StartScene}: nazwa sceny ładowanej z bazy zasobów.
	\end{itemize}
\end{itemize}

\textbf{Konfiguracja zasobów} jest używana wyłącznie przez potok zasobów i zawiera dodatkowe informacje o przetwarzanym zasobie wejściowym takie jak:
\begin{itemize}
	\item sekcja \textit{skybox}:
	\begin{itemize}
		\item \textit{Name}: nazwa używanej tekstury skybox.
	\end{itemize}
\end{itemize}

Konfiguracja jest zbiorem par klucz-wartość.
Wartości mogą być liczbą całkowitą lub ciągiem znaków i dla brakujących klucze mają wartość domyślną.
Odczyt i zapis odbywa się przy pomocy metod \textit{load()} i \textit{save()}.


\subsubsection{Jednostka sql\_db}
Obiekt \textit{sql\_db} reprezentujący połączenie z plikiem bazy danych SQLite.

SQLite posiada dynamiczny i słaby system typowania posiadający 5 typów prostych:
NULL, INTEGER (liczba całkowita maksymalnie 64-bitowa), REAL (64-bitowa liczba zmiennoprzecinkowa), TEXT ( ciąg znaków UTF-8/16) i BLOB: (blok pamięci).
Obiekt \textit{db} rozszerza ten ubogi system typów nowymi typami złożonymi bezpośrednio odpowiadającymi typom języka C zdefiniowanych w konfiguracji generatora: BYTE (uint8\_t), INT (uint32\_t), FLOAT (float), VEC2(vec2), VEC3(vec3), VEC4(vec4), MAT4(mat4), TEXT(UT\_string *), i KEY(hash\_t).
Dodatkowo każdy typ posiada wersję tablicową \textit{*\_ARRAY} (BYTE\_ARRAY, INT\_ARRAY itd.).

Obiekt \textit{sql\_db} pozwala na przeprowadzanie standardowych operacji wyboru (ang. select) i umieszczania (ang. insert) rekordów do wybranej tabeli.
Baza danych SQLite wciąż wewnętrznie używa typów prostych, ale wygenerowane przy użyciu X-makro metody \textit{select\_*()} i \textit{insert\_*()} automatycznie przeprowadzają serializację i deserializację typów złożonych.


\subsubsection{Jednostka asset\_db}
Obiekt \textit{asset\_db} reprezentuje bazę zasobów.
Używa on wewnętrznie obiektu \textit{sql\_db} i podobnie jak w nim użyto X-makro do dodania metod wyboru i umieszczania wartości dla specyficznej tabeli, kolumny i klucza.

Listing \ref{assetDbExample} demonstruje wybór i umieszczenie kod wartość FLOAT z tabeli \textit{directLight}, kolumny \textit{intensity} i klucza \textit{key}.
\lstset{language=C}
\begin{lstlisting}[caption={Deserializacja i serializacja wartości zmiennoprzecinkowej},captionpos=b,label={assetDbExample}]
float value =
	asset_db_select_directLight_intensity_float(assetDb, key).value;
asset_db_insert_directLight_intensity_float(assetDb, key,
	data_float_temp(value));
\end{lstlisting}

Obiekt ten jest intensywnie używany przez moduł zasobów do implementacji serializacji i deserializacji.

\subsection{Zasoby}

Moduł zawierajacy obiekty zasobów, które pozwalają na serializację i deserializację indywidualnych zasobów z bazy zasobów do formy używalnej przez resztę kodu silnika.

Wszystkie obiekty zasobów mają nazwy w formie \textit{asset\_*} i współdzielą następujące pola i metody:
\begin{itemize}
	\item klucz zasobu: jednoznacznie identyfikuje obiekt jako unikalny zasób i jest otrzymywany poprzez użycie funkcji skrótu na jego polach.
	\item wskaźnik do obiektu \textit{scene\_data} z modułu sceny: obiekty zasobów są zarządzane przez wskazywany obiekt zawierający dane sceny. Może być on używany podczas deserializacji.
	\item wskaźniki \textit{prev} i \textit{next}: pozwalają na użycie obiektu w liście dwukierunkowej biblioteki \textit{uthash}.
	\item \textit{calculate\_key()}: oblicza klucz zasobu, musi być wywoływany po każdej modyfikacji obiektu.
	\item \textit{serialize()}: serializacja, czyli zapis pól do bazy zasobów.
	Pola będące typami złożonymi wspieranymi przez obiekt \textit{asset\_db} są serializowane przy użyciu jego odpowiedniej metody \textit{insert\_*()} przyjmującej klucz zasobu.
	Dla pól będących obiektami zasobów wywoływana jest ich metoda \textit{serialize()}.
	\item \textit{deserialize()}: deserializacja, czyli odczyt pól z bazy zasobów.
	Metoda przyjmuje klucz zasobu żądanego zasobu i w sposób analogiczny do serializacji wypełnia pola używając metod \textit{select\_*()} obiektu \textit{asset\_db} i metod \textit{deserialize()}.
\end{itemize}
Powyższy interfejs jest zdefiniowany przez makra w jednostce \textit{common} i jest używany w reszcie jednostek modułu do implementacji obiektów zasobów.

Wspierane są następujące rodzaje obiektów zasobów zawierające dane opisujące:
\begin{itemize}
	\item \textit{asset\_object}: węzeł sceny,
	\item \textit{asset\_mesh}: siatkę,
	\item \textit{asset\_primitive}: prymityw,
	\item \textit{asset\_vertex\_attribute}: atrybut wierzchołka,
	\item \textit{asset\_camera}: kamera,
	\item \textit{asset\_direct\_light}: światło bezpośrednie,
	\item \textit{asset\_skybox}: skybox,
	\item \textit{asset\_font}: czcionka,
	\item \textit{asset\_material}: materiał,
	\item \textit{asset\_texture}: tekstura,
	\item \textit{asset\_image}: obraz,
	\item \textit{asset\_sampler}: próbnik.
\end{itemize}
Relacje pomiędzy nimi są inspirowane formatem glTF i zostały pokazane na diagramie \ref{asset_data_relationships}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=0.5cm]
		\tikzstyle{entity} = [rectangle, minimum width=3cm, minimum height=0.5cm,text centered, draw=black]
		\tikzstyle{refers} = [thick,->,>=stealth]
		
		\node (scene_data) [entity, right = 1cm of db] {scene\_data}; \def\y{scene_data};
		
		\def\x{asset_object}; \node (\x) [entity, below right = 1cm of scene_data] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_mesh}; \node (\x) [entity, below right = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_primitive}; \node (\x) [entity, below = of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_vertex_attribute}; \node (\x) [entity, below = of \y] {\myesc{\x}}; \edef\y{\x};
				
		\def\x{asset_camera}; \node (\x) [entity, above right = of asset_object] {\myesc{\x}}; \edef\y{\x};
		
		\def\x{asset_direct_light}; \node (\x) [entity, below left = -0.2cm and 1cm of scene_data] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_skybox}; \node (\x) [entity, below = 1cm of scene_data] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_font}; \node (\x) [entity, below left = 1cm and 0.5cm of scene_data] {\myesc{\x}}; \edef\y{\x};
		
		\def\x{asset_material}; \node (\x) [entity, left = of asset_primitive] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_texture}; \node (\x) [entity, left = 1.5cm of \y] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_image}; \node (\x) [entity, below right = 0.5cm and -1.0cm of asset_texture] {\myesc{\x}}; \edef\y{\x};
		\def\x{asset_sampler}; \node (\x) [entity, below left = 0.5cm and -1.0cm of asset_texture] {\myesc{\x}}; \edef\y{\x};

		\draw [refers] (scene_data) edge[] (asset_object);
		\draw [refers] (scene_data) edge[] (asset_skybox);
		\draw [refers] (scene_data) edge[] (asset_direct_light);
		\draw [refers] (scene_data) edge[] (asset_font);

		\draw [refers] (asset_object) edge[] (asset_mesh);
		\draw [refers] (asset_mesh) edge[] (asset_primitive);
		\draw [refers] (asset_primitive) edge[] (asset_vertex_attribute);
		\draw [refers] (asset_primitive) edge[] (asset_material);
		
		\draw [refers] (asset_material) edge[] (asset_texture);
		\draw [refers] (asset_texture) edge[] (asset_image);
		\draw [refers] (asset_texture) edge[] (asset_sampler);
		
		\draw [refers] (asset_object) edge[] (asset_camera);
		\draw [refers] (asset_object) edge[out=70,in=110, loop] (asset_object);
		
		\draw [refers] (asset_skybox) edge[] (asset_texture);
		\draw [refers] (asset_font) edge[] (asset_texture);
		
	\end{tikzpicture}
	\caption{Relacje pomiędzy obiektami zasobów w silniku (opracowanie własne)}
	\label{asset_data_relationships}
\end{figure}

\subsubsection{Zasób węzła \textit{asset\_object}}
Zasób węzła \textit{asset\_object} jest kontenerem zawierającym referencje do obiektów zasobów.

Węzeł zawiera macierz 4x4 z lokalną transformację przestrzeni oraz wskaźniki do zasobów (albo wartość NULL):
\begin{itemize}
	\item siatki,
	\item kamery,
	\item potomnych węzłów.
\end{itemize}
Ostateczna pozycja na scenie dla powyższych zasobów nie jest opisana bezpośrednio i musi zostać obliczana używając modelowania hierarchicznego przy pomocy grafu sceny - każdy zasób węzła jest używany do stworzenia odpowiedniego węzła grafu sceny.

\subsubsection{Zasób siatki \textit{asset\_mesh}}
Zasób siatki \textit{asset\_mesh} reprezentuje geometrię na scenie i składa się z listy prymitywów.
Podział na siatkę i prymitywy ma na celu zmniejszenie redundancji. Przykładowo siatka modelu auta może zawierać 4 identyczne koła renderowanych 4 razy tym samym prymitywem.
Siatka jest tożsama z geometrią pojedynczego modelu przygotowanego w programie do modelowania 3D.

\subsubsection{Zasób siatki \textit{asset\_primitive}}
Zasób prymitywu \textit{asset\_primitive} reprezentuje część siatki obiektu.
Jeden prymityw zawiera wszystkie dane wymagane do wygenerowania jednego polecenia rysowania i składa się z następujących elementów:
\begin{itemize}
	\item rodzaj topologii (\textit{VkPrimitiveTopology}),
	\item atrybuty wierzchołka,
	\item indeksy wierzchołków,
	\item materiał.
\end{itemize}

Prymityw zawiera po jednym zasobie atrybutu wierzchołka dla każdego wspieranego typu atrybutów (\textit{vertex\_attribute\_type}):
\begin{itemize}
	\item \textit{position}: pozycje,
	\item \textit{normal}: normalne,
	\item \textit{color}: kolory,
	\item \textit{texcoord}: koordynaty tekstury,
	\item \textit{tangent}: styczne.
\end{itemize}
Dodatkowo jeden zasób atrybutów jest używany do przechowywania indeksów wierzchołków.

Zasoby zawierają jedynie dane potrzebne do konstrukcji wierzchołków siatki - ostatecznie używany format wierzchołka (w tym rozdzielanie lub separacja atrybutów), tylko przez strumień wierzchołków \textit{vertex\_stream} w module renderera.

\subsubsection{Zasób siatki \textit{asset\_vertex\_attribute}}
Zasób atrybutu wierzchołka \textit{asset\_vertex\_attribute} reprezentuje dane pojedynczego atrybutu przechowywane w postaci tablicy komponentów, których typ to \textit{uint32\_t}, \textit{vec2}, \textit{vec3} lub \textit{vec4}.

\subsubsection{Zasób siatki \textit{asset\_camera}}
Zasób kamery \textit{asset\_camera} zawiera parametry, których część zależy od rodzaju używanego rzutu:
\begin{itemize}
	\item rzutowanie perspektywiczne:
	\begin{itemize}
		\item \textit{fovY}: pionowy kąt widzenia,
		\item \textit{aspectRatio}: proporcje okna (stosunek szerokości do wysokości),
	\end{itemize}
	\item rzutowanie ortogonalne:
		\begin{itemize}
		\item \textit{magX}: poziome powiększenie widoku,
		\item \textit{magY}: pionowe powiększenie widoku.
	\end{itemize}
\end{itemize}
Dodatkowo pola \textit{nearZ} oraz \textit{farZ} definiują są odległości bliskiej i dalekiej płaszczyzny przycinania wzdłuż osi +Z.

Powyższe parametry są używane do uzyskania macierzy rzutowania.
Ostateczna pozycja i rotacja kamery (i tym samym macierz widoku) musi być wyliczana na podstawie wynikowej transformacji przestrzeni węzła z kamerą.

\subsubsection{Zasób siatki \textit{asset\_direct\_light}}
Zasób światła bezpośredniego \textit{asset\_direct\_light} reprezentuje jedno światło na scenie.
Jego struktura jest inspirowana rozszerzeniem \textit{KHR\_lights\_punctual} formatu glTF.
Dostępne są dwa rodzaje świateł:
\begin{itemize}
	\item kierunkowe (ang. directional light),
	\item punktowe (ang. point light).
\end{itemize}
Wszystkie rodzaje świateł posiadają parametry:
\begin{itemize}
	\item intensywność: jasność światła (float),
	\item kolor: wartość RGB w liniowej przestrzeni kolorów (vec3).
\end{itemize}
Światło kierunkowe definiuje dodatkowy parametr kierunku będący wektorem w przestrzeni świata (vec3).
Światło punktowe definiuje:
\begin{itemize}
	\item pozycja: punkt w przestrzeni świata (vec3),
	\item zakres: promień sfery zdefiniowanej w pozycji światła. poza którą przez tłumienie intensywność osiąga zero (float).
\end{itemize}

\subsubsection{Zasoby skybox \textit{asset\_skybox}}
Zasób skybox \textit{asset\_skybox} opisuje składa się z zasobu tekstury oraz nazwy używanej przez konfigurację globalną.

\subsubsection{Zasób czcionki \textit{asset\_font}}
Zasób czcionki \textit{asset\_font} jest opisuje czcionkę bitmapową używaną do renderowania tekstu.
Składa się z:
\begin{itemize}
	\item nazwa: używana przez konfigurację globalną,
	\item zasób tekstury,
	\item alfabet: ciąg znaków ASCII,
	\item rozmiar znaku: rozmiar jednego glifu w pikselach (uint32\_t).
\end{itemize}

Rysunek \ref{font_texture} przedstawia przykładową teksturę dla czcionki Go-Mono \cite{GOMONOFONT}.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{images/font_texture.png}
	\caption{Przykładowa tekstura dla czcionki Go-Mono \cite{GOMONOFONT} (opracowanie własne)}
	\label{font_texture}
\end{figure}

\subsubsection{Zasób materiału \textit{asset\_material}}
Zasób materiału \textit{asset\_material} reprezentuje parametry używanego podczas renderowania powierzchni
prymitywów przy pomocy następujących parameterów:
\begin{itemize}
	\item \textit{baseColorFactor}: współczynnik koloru podstawowego (vec4);
	\item \textit{metallicFactor}: współczynnik metaliczności zakres, $\left[0,1\right]$;
	\item \textit{roughnessFactor}: współczynnik chropowatości $\left[0,1\right]$;
	\item \textit{metallicRoughnessTexture}: tekstura metaliczności-chropowatości, opcjonalna;
	\item \textit{normalMapTexture}: mapa normalnych, opcjonalna.
\end{itemize}

\subsubsection{Zasób tekstury \textit{asset\_texture}}
Zasób tekstury \textit{asset\_texture} reprezentuje próbkowany obraz i składa się z zasobu obrazu oraz zasobu próbnika.

\subsubsection{Zasób obrazu \textit{asset\_image}}
Zasób obrazu \textit{asset\_image} zawiera dane obrazu w postaci nieskompresowanej bitmapy.
Bitmapa to prostokątna tablica pikseli opisywana przez następujące parametry:
\begin{itemize}
	\item szerokość i wysokość (uint32\_t);
	\item liczba ścian: domyślnie 1 ściana, 6 ścian dla tekstur sześciennych (uint32\_t);
	\item liczba kanałów: specyfikuje liczbę komponentów i tym samym rozmiar piksela, jeden kanał jest reprezentowany przez jeden bajt (uint32\_t).
\end{itemize}

\subsubsection{Zasób próbnika \textit{asset\_sampler}}
Zasób próbnika \textit{asset\_sampler} reprezentuje parametry używane do stworzenia próbnika obrazu:
\begin{itemize}
	\item \textit{magFilter}: filtr powiększania (\textit{VkFilter}),
	\item \textit{minFilter}: filtr pomniejszania (\textit{VkFilter}),
	\item \textit{addressModeU}: tryb adresowania współrzędnych tekstur poza przedziałem $\left[0,1\right]$ dla osi X (\textit{VkSamplerAddressMode}),
	\item \textit{addressModeV}: tryb adresowania współrzędnych tekstur poza przedziałem $\left[0,1\right]$ dla osi Y (\textit{VkSamplerAddressMode}).
\end{itemize}

\subsubsection{Potok zasobów asset\_pipeline}
Potok zasobów składa się z dwóch części:
\begin{itemize}
	\item narzędzia wiersza poleceń \textit{asset\_pipeline},
	\item skryptu Python \textit{asset\_pipeline}.
\end{itemize}

Skrypt skanuje podkatalog z zasobami wejściowymi i wywołuje narzędzie z argumentami będącymi ścieżką zasoby wejściowego rodzajem konwertowanego zasobu wyjściowego.

Przykładowo potok zasobów może wywołać narzędzie 5 razy w sposób pokazany na listingu \ref{assetPipelineExample} tworząc pustą konfigurację globalną oraz pustą bazę zasobów wypełnioną zasobem skybox, zasobem czcionki Go-Mono oraz zasobami składającymi się na scenę Sponza opisanej plikiem glTF.
\lstset{language=verbatim}
\begin{lstlisting}[caption={Komendy wywoływane przez przykładowy potok zasobów},captionpos=b,label={assetPipelineExample}]
asset_pipeline empty_config
asset_pipeline empty_assets
asset_pipeline cubemap "skybox1" "/home/user/repo/cmake-build-debug/assets/cubemap/skybox1" png
asset_pipeline font "Go-Mono" "/home/sszczyrb/repo/cmake-build-debug/assets/font/Go-Mono.ttf"
asset_pipeline gltf "sponza" "/home/user/repo/cmake-build-debug/assets/gltf/sponza"
\end{lstlisting}

\subsection{Vulkan}

Vulkan to moduł zapewniający obiekty abstrahujące API Vulkan przeznaczone do użycia przez moduł renderera.

Moduł implementuje też mechanizm jednolitych buforów inspirowany grą \textit{Tom Clancy's Rainbow Six Siege} \cite{RAINBOWSIXSIEGE}.
Używa on automatycznie wygenerowanego kodu z jednostki descriptors i pozwala na wymaganą przez techniki renderowania bez dowiązań konsolidację zasobów buforów i obrazów w pojedyncze zasoby opisane jednym zbiorem deskryptorów.

\subsubsection{Urządzenie device}
Obiekt \textit{device} reprezentuje urządzenie.
Jest on podstawowym obiektem przygotowującym podstawowe funkcjonalności używane przez resztę obiektów modułu.


Obiekt oferuje następujące funkcjonalności:
\begin{itemize}
	\item obsługa okna,
	\item inicjalizacja Vulkan,
	\item wykonywanie poleceń one-shot.
\end{itemize}

Okno jest tworzone przy użyciu biblioteki GLFW i jest reprezentowane obiektem \textit{GLFWwindow}.
Listing \ref{deviceglfw} ilustruje stworzenie okna i użycie go do zarejestrowania funkcji wywołań zwrotnych używane do wykrywania zmiany rozmiaru okna oraz przechwytywania danych wejściowych myszy i klawiatury.
Kursor myszy jest ukryty i jego fizyczna pozycja w oknie jest
centrowana co klatkę - program ma dostęp do wirtualnej pozycji, co pozwala na nieograniczony ruch myszy.
Wirtualna pozycja kursowa jest używana do implementacji sterowania kamerą.
\lstset{language=C}
\begin{lstlisting}[caption={Użycie biblioteki GLFW do stworzenia okna i rejestracji funkcji wywołań zwrotnich},captionpos=b,label={deviceglfw}]
// Inicjalizacja biblioteki GLFW.
assert(glfwInit() == GLFW_TRUE);
assert(glfwVulkanSupported() == GLFW_TRUE);

// Stworzenie okna.
glfwDefaultWindowHints();
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
GLFWwindow *window = glfwCreateWindow(640, 480, "Window caption", NULL, NULL);

// Rejestracja funkcji wywołania zwrotnego.
glfwSetWindowUserPointer(window, callbackData);
glfwSetFramebufferSizeCallback(window, framebuffer_resize_callback);
glfwSetKeyCallback(window, key_callback);
glfwSetCursorPosCallback(window, mouse_callback);

// Wirtualny kursor myszy.
glfwSetInputMode(vkd->window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
\end{lstlisting}

Obiekt inicjalizuje podstawowe obiekty Vulkan: instancja, powierzchnia okna, urządzenia fizyczne, urządzenie logiczne, kolejki oraz wskaźniki funkcji rozszerzeń.

Instancja deklaruje użycie wersji Vulkan 1.2 oraz następujących rozszerzeń instancji:
\begin{itemize}
	\item \textit{VK\_KHR\_get\_physical\_device\_properties2};
	\item rozszerzenia zwrócone przez funkcję \textit{glfwGetRequiredInstanceExtensions()} używane do stworzenia powierzchni okna (\textit{VK\_KHR\_surface} i dodatkowe rozszerzenie zależące od system okien);
	\item w trybie debugowania VK\_EXT\_debug\_utils.
\end{itemize}
Dodatkowo w trybie debugowania używana jest warstwa walidacji \textit{VK\_LAYER\_KHRONOS\_validation} oraz komunikator debugowania dla instancji.

Powierzchnia okna jest tworzona przy użyciu funkcji \textit{glfwCreateWindowSurface()}.

Lista urządzeń fizycznych jest przefiltrowana do listy kandydatów przy użyciu następujących kryteriów wsparcia:
\begin{itemize}
\item wersja Vulkan: Vulkan 1.2;
\item dostępne rodziny kolejek: graficzne i prezentacji;
\item rozszerzenia urządzenia:
	\begin{itemize}
	\item \textit{VK\_KHR\_swapchain};
	\item \textit{VK\_KHR\_dynamic\_rendering};
	\item \textit{VK\_KHR\_shader\_non\_semantic\_info}: w trybie debugowania, używane przez debugPrintf;
	\end{itemize}
\item wcześniej utworzonej powierzchni okna;
\item funkcjonalności urządzenia fizycznego:
	\begin{itemize}
	\item Vulkan 1.0 Core:
		\begin{itemize}
		\item samplerAnisotropy: filtrowanie anizotropowego;
		\item shaderUniformBufferArrayDynamicIndexing: jednolite dynamiczne indeksowanie tablic buforów uniform;
		\item shaderSampledImageArrayDynamicIndexing: jednolite dynamiczne indeksowanie tablic próbkowanych obrazów;
		\item multiDrawIndirect: polecenia wielokrotnego rysowania pośredniego;
		\item drawIndirectFirstInstance: polecenia rysowania pośredniego z offsetem indeksu instancji;
		\end{itemize}
	\item Vulkan 1.2 Core:
		\begin{itemize}
		\item descriptorIndexing: indeksowanie deskryptorów;
		\item shaderSampledImageArrayNonUniformIndexing: niejednolite dynamiczne indeksowanie tablic próbkowanych obrazów;
		\item descriptorBindingVariableDescriptorCount: dowiązania deskryptora o zmiennej wielkości;
		\item descriptorBindingPartiallyBound: częściowe dowiązanie deskryptorów;
		\item runtimeDescriptorArray: nieograniczone tablice deskryptorów;
		\item scalarBlockLayout: układ pamięci scalar;
		\end{itemize}
	\item \textit{VK\_KHR\_dynamic\_rendering}:
	\begin{itemize}
		\item dynamicRendering: dynamiczne przebiegi renderowania.
	\end{itemize}
	\end{itemize}
\end{itemize}
Każde urządzenie fizyczne listy kandydatów ma nadawany ranking poprzez oceniane jego typu od najlepszego do najgorszego:
\begin{itemize}
	\item dyskretne GPU,
	\item zintegrowane GPU,
	\item wirtualne GPU,
	\item CPU.
\end{itemize}
Urządzenie fizyczne z najwyższym rankingiem jest ostatecznie wybierane z listy kandydatów.

Urządzenie logiczne jest tworzone wspierając funkcjonalności sprawdzanie podczas wyboru urządzenia fizycznego oraz albo po jednej kolejce graficznej i prezentacji, albo jedna kolejka ,,uniwersalna'' wspierająca obie rodziny poleceń.

Po stworzeniu urządzenia logicznego funkcja \textit{vkGetDeviceProcAddr()} jest uzywana do pobrania następujących funkcji rozszerzeń:
\begin{itemize}
	\item \textit{VK\_KHR\_dynamic\_rendering}
	\begin{itemize}
		\item vkCmdBeginRenderingKHR,
		\item vkCmdEndRenderingKHR,
	\end{itemize}
	\item \textit{VK\_EXT\_debug\_utils}
	\begin{itemize}
		\item vkCmdBeginDebugUtilsLabelEXT,
		\item vkCmdEndDebugUtilsLabelEXT,
		\item vkCmdInsertDebugUtilsLabelEXT,
		\item vkSetDebugUtilsObjectNameEXT.
	\end{itemize} 
\end{itemize}

Polecenia one-shot są przeznaczone do jednokrotnego transferu dużych ilości danych z bazy zasobów do pamięci DEVICE\_LOCAL przez rozpoczęciem pętli głównej renderowania.


Bufor poleceń one-shot jest alokowany podczas tworzenia obiektu \textit{device} z osobnej puli komend one-shot. Jest on przeznaczona do użycia z kolejką graficzną i stworzona z flagą TRANSIENT, która wskazuje sterownikowi graficznemu, że zaalokowane bufory komend będą krótkotrwałe i zresetowane bądź zwolnione w stosunkowo krótkim czasie, co teoretycznie pozwala sterownikowi na optymalizację metody alokacji pamięci.

Nagrywanie poleceń one-shot rozpoczyna się wywołaniem metody \textit{begin\_one\_shot\_commands()} rozpoczynającej nagrywanie bufora poleceń funkcją \textit{vkBeginCommandBuffer()} z flagą użycia \textit{ONE\_TIME\_SUBMIT} wskazującą, że będzie on wykonany tylko jeden raz.

Nagrywanie jak kończone wywołaniem metody \textit{end\_one\_shot\_commands()}, która wykonuje następujące czynności:
\begin{itemize}
	\item kończy nagrywanie bufora komend one-shot funkcją \textit{vkEndCommandBuffer()},
	\item wysyła bufor poleceń do kolejki graficznej funkcją \textit{vkQueueSubmit()},
	\item czeka na CPU aż kolejka zakończy wykonywanie poleceń na GPU funkcją \textit{vkQueueWaitIdle()},
	\item resetuje bufor komend one-shot poprzez reset całej puli komend one-shot funkcją \textit{vkResetCommandPool()}.
\end{itemize}
Synchronizacja między krokiem 2. i 4. zapobiega próbie zresetowania bufora poleceń wciąż używanego przez GPU. Resetowanie puli poleceń automatycznie resetuje zaalokowane z niego bufory poleceń i jest uznawane za szybsze od manualnego resetowania buforów poleceń przez warstwy walidacji, której ostrzeżenie przedstawia listing \ref{perfWarn1}
\lstset{language=verbatim}
\begin{lstlisting}[caption={Ostrzeżenie wydajnościowe wyemitowane przez warstwy walidacji},captionpos=b,label={perfWarn1}]
Validation Performance Warning:
[ UNASSIGNED-BestPractices-vkCreateCommandPool-command-buffer-reset ]
Object 0: handle = 0x626000015100, type = VK_OBJECT_TYPE_DEVICE;
| MessageID = 0x8728e724
| vkCreateCommandPool(): VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER is set.
Consider resetting entire pool instead.
\end{lstlisting}

Bufor poleceń one-shot może być wypełniony dowolnymi poleceniami graficznymi i transferu, ale obiekt oferuje metody pomocnicze wykonujące podstawowe operacji używane podczas transferu danych.

Metody \textit{one\_shot\_copy\_buffer\_to\_buffer()} i \textit{one\_shot\_copy\_buffer\_to\_image()} kopiują dane w obrębie GPU z bufora do bufora lub obrazu używając poleceń transferu \textit{vkCmdCopyBuffer()} i \textit{vkCmdCopyBufferToImage()}. Metoda \textit{one\_shot\_copy\_buffer\_to\_image()} wymaga układu docelowego obrazu \textit{TRANSFER\_DST\_OPTIMAL}.

Metoda \textit{one\_shot\_generate\_mipmaps()} generuje poziomy mipmap dla tekstur 2D. Baza zasobów nie przechowuje poziomów mipmap, dlatego metoda jest wywoływania po transferze danych zasobu obrazu do pierwszego poziomu mipmapy obrazu w celu automatycznej generacji reszty poziomów. Metoda zakłada układ obrazu \textit{TRANSFER\_DST\_OPTIMAL} i pozostawia go w układzie \textit{SHADER\_READ\_ONLY\_OPTIMAL}.

Metoda \textit{one\_shot\_transition\_image\_layout()} zmienia układ całego obrazu, tj. jego wszystkich warstw i poziomów mipmap. Używa ona do tego metody \textit{transition\_image\_layout\_command()}.

Metoda \textit{transition\_image\_layout\_command()} przeprowadza dla części obrazu przejście ze starego układu na nowy układ poprzez nagranie bariery pamięci obrazu \textit{VkImageMemoryBarrier}.
Użycie bariery potoku wymaga zdefiniowania całej zależności pamięci, dlatego każde przejście układu obrazów wymaga zdefiniowania jak dokładnie obraz będzie używany po przejściu i zakodowania tej wiedzy używając źródłowych i docelowych etapów potoku oraz zakresów dostępów.
Z tego powodu implementacja metody musi być świadoma późniejszego użycie obrazu po przejściu, co zostało podsumowane w tabeli \ref{transition_logic}.
\begin{center}
	\begin{longtable}{ |>{\RaggedRight}p{7cm}||>{\RaggedRight}p{7cm}|}
		\hline
		przejście układu obrazu \newline użycie obrazu po przejściu & zależność pamięci (zakresy dostępu, etapy potoku) \\
		\hline \hline
		\mbox{UNDEFINED} -> \mbox{TRANSFER\_DST\_OPTIMAL} \newline inicjalizacja poleceniem transferu & 0 -> \mbox{TRANSFER\_WRITE}, \mbox{TOP\_OF\_PIPE} -> \mbox{TRANSFER} \\
		\hline
		\mbox{TRANSFER\_DST\_OPTIMAL} -> \mbox{TRANSFER\_SRC\_OPTIMAL} \newline źródło polecenia transferu po inicjalizacji (generacje mipmap) & \mbox{TRANSFER\_WRITE} -> \mbox{TRANSFER\_READ},\newline \mbox{TRANSFER} -> \mbox{TRANSFER} \\
		\hline
		\mbox{TRANSFER\_SRC\_OPTIMAL} -> \mbox{SHADER\_READ\_ONLY\_OPTIMAL} \newline odczyt przez shader fragmentów (po generacji mipmap) & \mbox{TRANSFER\_READ} -> \mbox{SHADER\_READ},\newline \mbox{TRANSFER} -> \mbox{FRAGMENT\_SHADER} \\
		\hline 
		\mbox{TRANSFER\_DST\_OPTIMAL} -> \mbox{SHADER\_READ\_ONLY\_OPTIMAL} \newline odczyt przez shader fragmentów  (brak generacji mipmap) & \mbox{TRANSFER\_WRITE} -> \mbox{SHADER\_READ},\newline \mbox{TRANSFER} -> \mbox{FRAGMENT\_SHADER} \\
		\hline 
		\mbox{UNDEFINED} -> \mbox{COLOR\_ATTACHMENT\_OPTIMAL} \newline dołączenie koloru (pierwszy raz z klatce) & \mbox{0} -> \mbox{COLOR\_ATTACHMENT\_WRITE},\newline \mbox{TOP\_OF\_PIPE} -> \mbox{COLOR\_ATTACHMENT\_OUTPUT} \\
		\hline 
		\mbox{UNDEFINED} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_OPTIMAL} \newline dołączenie głebi/szablonu (odczyt i zapis, pierwszy raz z klatce) & \mbox{0} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_READ} | \mbox{DEPTH\_STENCIL\_ATTACHMENT\_WRITE},\newline \mbox{TOP\_OF\_PIPE} -> \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{LATE\_FRAGMENT\_TESTS} \\
		\hline 
		\mbox{DEPTH\_STENCIL\_ATTACHMENT\_OPTIMAL} -> \mbox{DEPTH\_STENCIL\_READ\_ONLY\_OPTIMAL} \newline dołączenie głebi/szablonu (tylko do odczytu, wcześniej odczyt i zapis) & \mbox{DEPTH\_STENCIL\_ATTACHMENT\_WRITE} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_READ} | \mbox{SHADER\_READ},\newline \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{LATE\_FRAGMENT\_TESTS} -> \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{FRAGMENT\_SHADER} \\
		\hline
		\mbox{DEPTH\_STENCIL\_READ\_ONLY\_OPTIMAL} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_OPTIMAL} \newline dołączenie głebi/szablonu (odczyt i zapis, wcześniej tylko do odczytu) & \mbox{DEPTH\_STENCIL\_ATTACHMENT\_READ} | \mbox{SHADER\_READ} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_WRITE},\newline \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{FRAGMENT\_SHADER} -> \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{FRAGMENT\_SHADER} \\
		\hline
		\mbox{COLOR\_ATTACHMENT\_OPTIMAL} -> \mbox{SHADER\_READ\_ONLY\_OPTIMAL} \newline dołączenie koloru (tylko do odczytu, wcześniej odczyt i zapis) & \mbox{COLOR\_ATTACHMENT\_WRITE} -> \mbox{SHADER\_READ},\newline  \mbox{COLOR\_ATTACHMENT\_OUTPUT} -> \mbox{FRAGMENT\_SHADER} \\
		\hline
		\mbox{SHADER\_READ\_ONLY\_OPTIMAL} -> \mbox{COLOR\_ATTACHMENT\_OPTIMAL} \newline dołączenie koloru (odczyt i zapis, wcześniej tylko do odczytu) & \mbox{SHADER\_READ} -> \mbox{COLOR\_ATTACHMENT\_WRITE},\newline  \mbox{FRAGMENT\_SHADER} -> \mbox{COLOR\_ATTACHMENT\_OUTPUT} \\
		\hline
		\mbox{COLOR\_ATTACHMENT\_OPTIMAL} -> \mbox{COLOR\_ATTACHMENT\_OPTIMAL} \newline dołączenie koloru (odczyt i zapis w poprzednim i obecnym przebiegu renderowania) & \mbox{COLOR\_ATTACHMENT\_WRITE} -> \mbox{COLOR\_ATTACHMENT\_READ} | \mbox{COLOR\_ATTACHMENT\_WRITE},\newline  \mbox{COLOR\_ATTACHMENT\_OUTPUT} -> \mbox{COLOR\_ATTACHMENT\_OUTPUT} \\
		\hline
		\mbox{DEPTH\_STENCIL\_ATTACHMENT\_OPTIMAL} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_OPTIMAL} \newline dołączenie głębi/szablonu (odczyt i zapis w poprzednim i obecnym przebiegu renderowania) & \mbox{DEPTH\_STENCIL\_ATTACHMENT\_WRITE} -> \mbox{DEPTH\_STENCIL\_ATTACHMENT\_READ} | \mbox{DEPTH\_STENCIL\_ATTACHMENT\_WRITE},\newline  \mbox{LATE\_FRAGMENT\_TESTS} -> \mbox{EARLY\_FRAGMENT\_TESTS} | \mbox{LATE\_FRAGMENT\_TESTS} \\
		\hline
		\mbox{COLOR\_ATTACHMENT\_OPTIMAL} -> \mbox{PRESENT\_SRC\_KHR} \newline prezentacja obrazu & \mbox{COLOR\_ATTACHMENT\_WRITE} -> \mbox{MEMORY\_READ},\newline  \mbox{COLOR\_ATTACHMENT\_OUTPUT} -> \mbox{BOTTOM\_OF\_PIPE} \\
		\hline
		
	\caption{Logika przejść układu i zależności pamięci obrazu (opracowanie własne)} 
	\label{transition_logic}
	\end{longtable}
\end{center}
Metoda jest używana w poleceniach one-shot oraz przez graf renderowania do zapewnienia przejść układu i zależności pamięci obrazów pomiędzy przebiegami renderowania.

\subsubsection{Łańcuch wymiany swap\_chain}
Obiekt \textit{swap\_chain} reprezentuje łańcuch wymiany i zawiera następujące elementy:
\begin{itemize}
	\item łańcuch wymiany \textit{VkSwapchain},
	\item lista uchwytów prezentowalnych obrazów \textit{VkImage},
	\item lista widoków prezentowalnych obrazów \textit{VkImageView}.
\end{itemize}

Preferowany tryb prezentacji to \textit{MAILBOX}. Jeśli jest niedostępny, to wybierany jest zawsze wspierany tryb prezentacji \textit{FIFO}.

Preferowany format i przestrzeń kolorów to \textit{B8G8R8A8\_SRGB} i SRGB. Jeśli nie są dostępne, to wybierane są pierwszy dostępny.
Formaty z rodziny BGRA i przestrzeń kolorów SRGB powierzchni okna są zawsze wspierane na systemie Windows i w czasie pisania pracy są one wspierane w ponad $96\%$ systemów Linux \cite{GPUINFO}.
Obliczenia modelu oświetlenia będące wyjściem shaderów fragmentów odbywają się w liniowej przestrzeni kolorów. Użycie formatu \textit{B8G8R8A8\_SRGB} zamiast \textit{B8G8R8A8\_UNORM} pozwala na ominięcie ręcznej konwersji z przestrzeni liniowej do SRGB podczas renderowania bezpośrednio do prezentowalnej tekstury - konwersja zostanie automatycznie przeprowadzona przez sterownik.

Lista uchwytów prezentowalnych obrazów jest wypełniania w pętli używając funkcji \textit{vkGetSwapchainImagesKHR()}.
Następnie tworzone są widoki obrazów pozwalające przebiegom renderowania \textit{render\_pass} używać prezentowalne obrazy jako dołączenia koloru.


\subsubsection{Bufor buffer}
Obiekt \textit{buffer} reprezentuje pojedynczy bufor Vulkan.
Rozróżniane są następujące typy bufora (\textit{buffer\_type}):
\begin{itemize}
	\item \textit{geometry\_index}: bufor indeksów geometrii,
	\item \textit{geometry\_vertex}: bufor wierzchołków geometrii,
	\item \textit{uniform}: bufer uniform,
	\item \textit{indirect\_draw}: bufor poleceń rysowania pośredniego.
\end{itemize}
Bufory wierzchołków, indeksów i poleceń rysowania pośredniego są źródłem danych odczytywanych przez stałe funkcji potoku graficznego.
Bufory uniform są źródłem danych odczytywanych przez shadery.

Bufor zawiera dwa obiekty Vulkan: bufor \textit{VkBuffer} oraz dowiązaną do niego alokację pamięci \textit{VkDeviceMemory}.
Typ bufora przekłada się na flagi używane podczas ich tworzenia, co zostało podsumowane w tabeli \ref{params_buffer}.
\begin{table}[!htr]
	\centering
	\begin{tabular}{ |p{3cm}||>{\RaggedRight}p{4cm}|>{\RaggedRight}p{4cm}|}
		\hline
		Typ bufora & flagi użycia bufora \mbox{\textit{VkBufferUsageFlags}} & flagi właściwości pamięci \textit{VkMemoryPropertyFlags} \\
		\hline \hline
		\textit{geometry\_index} & \mbox{TRANSFER\_DST} | \mbox{VERTEX\_BUFFER} & DEVICE\_LOCAL \\
		\hline 
		\textit{geometry\_vertex} & \mbox{TRANSFER\_DST} | \mbox{INDEX\_BUFFER} & DEVICE\_LOCAL \\
		\hline 
		\textit{uniform} & \mbox{UNIFORM\_BUFFER} &  \mbox{HOST\_VISIBLE} | \mbox{HOST\_COHERENT} \\
		\hline 
		\textit{indirect\_draw} & \mbox{TRANSFER\_DST} | \mbox{INDIRECT\_BUFFER} &  \mbox{HOST\_VISIBLE} | \mbox{HOST\_COHERENT}\\
		\hline
	\end{tabular}
	\caption{Zależność flag obiektów Vulkan od typu bufora (opracowanie własne)} 
	\label{params_buffer}
\end{table}

Obiekt utrzymuje listę elementów bufora \textit{buffer\_element}. Zawiera ona bloki pamięci CPU, które są kopiowane do GPU metodą \textit{send\_to\_device()}.
Sposób transferu pamięci z CPU do GPU zależy od użytej flagi właściwości pamięci.
Dla pamięci \textit{HOST\_VISIBLE} używane jest mapowanie pamięci - funkcja \textit{vkMapMemory()} zwraca wskaźnik CPU do regionu pamięci GPU, do którego bezpośrednio kopiowana jest pamięć używając funkcji \textit{memcpy()}.
Dla reszty rodzajów pamięci niemogących być bezpośrednio zapisywanych przez CPU (w tym pamięć DEVICE\_LOCAL) tworzony jest bufor tymczasowy \textit{VkBuffer}, do którego pamięć CPU jest kopiowana używając polecenia one-shot \textit{one\_shot\_copy\_buffer\_to\_buffer()}.


\subsubsection{Obraz image}
Obiekt \textit{image} reprezentuje pojedynczy obraz Vulkan.
Wspierane są następujące typy obrazu (\textit{image\_type}):
\begin{itemize}
	\item \textit{material\_base\_color}: tekstura koloru podstawowy materiału,
	\item \textit{material\_parameters}: tekstura parametrów (metaliczności-chropowatości) materiału,
	\item \textit{material\_normal\_map}: mapa normalnych materiału,
	\item \textit{cubemap}: tekstura sześcienna,
	\item \textit{font\_bitmap}: tekstura czcionki bitmapowej,
	\item \textit{offscreen\_f16}: pozaekranowa tekstura o formacie \textit{R16\_SFLOAT},
	\item \textit{offscreen\_depth\_buffer}: pozaekranowy bufor głębi,
	\item \textit{offscreen\_r8}: pozaekranowa tekstura o formacie \textit{R8\_UNORM}.
\end{itemize}

Wszystkie rodzaje tekstur mogą być próbkowane w shaderach poprzez deskryptory.
Tekstury pozaekranowe mogą być też używane jako cele renderowania, tj. dołączenia koloru i głębi/szablonu potoku graficznego.

Obraz utrzymuje trzy obiekty Vulkan: obraz \textit{VkImage}, dowiązaną do niego alokację pamięci \textit{VkDeviceMemory} oraz widok na niego \textit{VkImageView}.
Ich informacje tworzenia zależą od wejścia metody \textit{init()}: wysokości, szerokości, liczby kanałów oraz typu obrazu.

Typ obrazu przekłada się głównie na flagi użycia obrazu \textit{VkImageUsageFlags}.
Tekstury pozaekranowe używają flag \textit{SAMPLED} i \textit{COLOR\_ATTACHMENT}.
Reszta obrazów używa flag \textit{SAMPLED}, \textit{TRANSFER\_SRC} i \textit{TRANSFER\_DST}.

Obrazy używają wyłącznie kafelkowania optymalnego, które jest wydajniejsze od kafelkowania liniowego i znacznie szerzej wspierane \cite{GPUINFO}.

Obrazy posiadają jedną warstwę i jeden poziom mipmap z wyjątkiem tekstur sześciennych (sześć warstw) oraz tekstur koloru podstawowy materiału (maksymalna możliwa liczba poziomów mipmap).

Format obrazu zależy od typu obrazu i liczby kanałów i jest ustalany funkcją \textit{find\_image\_format()}.
Generuje ona listę formatów, które spełniają wymagania specyfikowane przez typ obrazu i posiadają liczbę komponentów równą lub większą liczbie kanałów używanej przez obraz.
Ostateczny format to ten z najmniejszą liczbą komponentów wciąż wspierany przez sterownik, co pozwala na zaoszczędzenie pamięci GPU.

Pamięć obrazu jest zawsze w pamięcią \textit{DEVICE\_LOCAL}, ponieważ transport z GPU do CPU nigdy nie zachodzi i ten typ pamięci powinien skutkować szybszym dostępem po stronie GPU.

Typ stworzonego widoku \textit{VkImageViewType} to \textit{2D} pozwalający shaderom GLSL na probkowanie przy użyciu zmiennych shaderów o typie \textit{sampler2D}. Wyjątkiem są tekstury sześcienne, które wymagają widoku \textit{CUBE} pozwalającego na próbkowanie zmiennymi \textit{samplerCube}.

Kopiowanie danych obrazu z CPU do GPU to ważna operacja pozwalającą na wstępne wypełnienie obrazów danymi załadowanymi z bazy zasobów. Nie jest ona wymagana dla obrazów niebędących teksturami pozaekranowymi.
Jest ona wykonywana metodą \textit{send\_to\_device()}, która podobnie do obiektów \textit{buffer} używa poleceń one-shot do wypełnienia zmapowanego bufora tymczasowego danymi obrazu i skopiowania go poleceniem one-shot \textit{one\_shot\_copy\_buffer\_to\_image()} do pamięci GPU.
Dodatkowo bufor poleceń one-shot jest używany do wygenerowania wymaganych poziomów mipmap.
 
\subsubsection{Jednolity bufor stałych unified\_constant\_buffer}
Obiekt \textit{unified\_constant\_buffer} reprezentuje jednolity bufor stałych - jeden duży bufor uniform zawierający wszystkie informacje używane przez shadery.

Obiekt zawiera struktury \textit{*\_uniform\_buffer\_data} z wygenerowanego nagłówka \textit{descriptors} pozwalające aplikacji na aktualizację wewnętrznej struktury bufora uniform z poziomu języka C z poszanowaniem zasad układu pamięci scalar.

Dodatkowo obiekt utrzymuje dwie kopie danych bufora i pozwala na aktualizację tylko tej kopii używanej przez obecną klatkę. Podwaja to rozmiar zaalokowanej pamięci GPU, ale pozwala na renderowanie klatek w locie.

Metoda \textit{update()} używa wejściowego wskaźnika funkcji do aktualizacji struktur \textit{*\_uniform\_buffer\_data}, które są następnie kopiowane do pamięci GPU bufora uniform metodą \textit{send\_to\_device()}.

Obecnie jednolity bufor stałych ma następującą strukturę:
\begin{itemize}
	\item dane instancji \textit{instances}:
	Tablica przeznaczona do indeksowana zmienną shadera \textit{gl\_InstanceIndex} pozwalająca na otrzymanie danych renderowanego prymitywu:
	\begin{itemize}
		\item \textit{mat4 modelMat}: macierz modelu,
		\item \textit{uint materialId}: identyfikator materiału.
	\end{itemize}
	Rozmiar tablicy jest sterowany konfiguracją globlaną (\textit{MaxPrimitiveElementCount}).
	
	\item dane globalne \textit{global}:
	Dane współdzielone przez wszystkie polecenia rysowania:
	\begin{itemize}
		\item macierze widoku i rzutowania,
		\item tablica danych materiałów,
		\item tablice danych świateł bezpośrednich,
		\item dane skybox: identyfikator tekstury skybox,
		\item czcionka i tekst debugowania,
		\item dane używane do renderowania tekstu debugowania,
		\item identyfikatory tekstur pozaekranowych.
	\end{itemize}
\end{itemize}

Konsolidacja buforów uniform jest techniką renderowanie bez dowiązań.
Większość przebiegów renderowania używa tylko części danych jednolitego bufora stałych, ale jest on zawsze w całości dowiązany przez deskryptory \textit{descriptors} na początku klatki i tym samym dostępny w całym potoku graficznym.


\subsubsection{Jednolity bufer geometrii unified\_geometry\_buffer}
Obiekt \textit{unified\_geometry\_buffer} reprezentuje jednolity bufor geometrii - bufor wierzchołków i bufor indeksów zawierający całą geometrię używaną przez polecenia rysowania.

Metoda \textit{record\_bind\_command} dowiązuje do bufora poleceń bufory wierzchołków i indeksów poleceniami \textit{vkCmdBindVertexBuffers()} i \textit{vkCmdBindIndexBuffers()}.

Metody \textit{update()} i \textit{send\_to\_device()} są używane do aktualizacji i transferu do GPU zawartości buforów używając obiektu \textit{vertex\_stream}.


\subsubsection{Strumień wierzchołków vertex\_stream}
Obiekt \textit{vertex\_stream} reprezentuje strumień wierzchołków zawierający całą geometrię sceny.

Obiekt składa się z dwóch tablic: wierzchołków (tablica \textit{vertex}) i ich indeksy (tablica \textit{uint32\_t}).

Metoda \textit{add\_geometry()} pozwala na dodanie do strumienia wierzchołka tablic zawierających poszczególne atrybuty i indeksy.
Metoda jest używana przez pamięć podręczną renderowania \textit{render\_cache} do zebrania geometrii wszystkich renderowanych prymitywów w pojedynczy blok pamięci CPU przekazywany jednolitemu buforowi geometrii.

Silnik używa przekładanych atrybutów (ang. interleaved attributes) - wszystkie atrybuty wierzchołka są przechowywane w ramach jednej struktury \textit{vertex} przedstawionej na listingu \ref{vertexStreamVertex}.
\lstset{language=C}
\begin{lstlisting}[caption={Struktura wierzchołka \textit{vertex}},captionpos=b,label={vertexStreamVertex}]
typedef struct vertex {
	vec3 position;
	vec3 normal;
	vec3 color;
	vec2 texCoord;
	vec4 tangent;
} vertex;
\end{lstlisting}

Metody \textit{get\_vertex\_buffer\_binding\_count()}, \textit{get\_vertex\_buffer\_binding\_description()} i \textit{get\_vertex\_buffer\_attribute\_descriptions()} zwracają struktury Vulkan używane podczas tworzenia potoku graficznego kompatybilnego ze strumieniem wierzchołków.


\subsubsection{Tekstury textures}
Obiekt \textit{textures} zarządza wszystkimi teksturami, które są tylko do odczytu i nie są pozaekranowe, i używającymi ich materiałami.

Tekstura składa się z następujących elementów:
\begin{itemize}
	\item zasób tekstury,
	\item obraz,
	\item próbnik,
	\item identyfikator tekstury.
\end{itemize}
Tekstury są przechowywane w tablicy mieszającej, której kluczem jest jej zasób, co pozwala na uniknięcie duplikacji pamięci.

Metoda \textit{add\_texture()} tworzy nową teksturę na podstawie wejściowego zasobu tekstury.
Obraz i próbnik są tworzone na podstawie danych zawartych w zasobie tekstury.
Identyfikator tekstury to 32-bitowa liczba całkowita. Pierwszy identyfikator to zero, każdy następny jest uzyskiwany poprzez inkrementację. Maksymalna liczba stworzonych tekstur jest równa maksymalnej liczbie deskryptorów próbkowanych obrazów.

Metoda \textit{send\_to\_device()} wysyła obrazy tekstur do GPU. 

Dostęp do tekstur w shaderach odbywa się przy użyciu tablicy deskryptorów próbkowanych obrazów znajdującą się w ostatnim dowiązaniu deskryptorów \textit{descriptors}.
Identyfikator tekstury jest indeksem w tej tablicy używanym przez shadery i podczas aktualizacji deskryptorów.

Funkcja \textit{glsl\_add\_textures()} dodaje kwalifikatory układu do kodu GLSL shadera pozwalające na dostęp do tablicy tekstur z dowiązania o numerze $x$, których forma została przedstawiona na listingu \ref{textureQualifers}.
\lstset{language=GLSL}
\begin{lstlisting}[caption={Kwalifikatory układu dla tekstur \textit{textures}},captionpos=b,label={textureQualifers}]
	layout(set = 0, binding = x) uniform sampler2D textures2D[];
	layout(set = 0, binding = x) uniform samplerCube texturesCube[];
\end{lstlisting}
Można zauważyć, że definiowane są dwie zmienne shadera posiadające identyczne numery zbioru i dowiązania deskryptorów, ale różne typy zmiennych shadera.
Ta sytuacja jest dozwolona przez specyfikację Vulkan z zastrzeżeniem, że shader może używać jedynie tych zmiennych shadera, których typ odpowiada rodzajowi dowiązanego deskryptora.
Przykładowo, jeśli indeks \textit{i} w tablicy deskryptorów tekstur opisuje teksturę 2D, to dostęp do niej w
shaderze musi się odbywać przy użyciu wyrażenia \textit{textures2D[i]} - użycie wyrażenia \textit{texturesCube[i]} jest niezdefiniowanym zachowaniem.
Technika ta eliminuje potrzebę tworzenia i zarządzania osobnymi dowiązaniami deskryptorów dla różnych rodzajów tekstur i pozwala na unifikację próbkowania. Dostęp do tekstury wymaga jedynie wiedzy o jego identyfikatorze \textit{i} i rodzaju, co zostało przedstawione na listingu \ref{textureSampling}.
\lstset{language=GLSL}
\begin{lstlisting}[caption={Przykład próbkowania tekstur},captionpos=b,label={textureSampling}]
	vec4 tex2DSample = texture(textures2D[i], vec2(0));
	vec4 texCubeSample = texture(texturesCube[], vec3(0));
\end{lstlisting}

Materiał składa się z następujących elementów:
\begin{itemize}
	\item zasób materiału,
	\item tekstury materiału:
	\begin{itemize}
		\item tekstura koloru podstawowego,
		\item tekstura metaliczności-chropowatości,
		\item mapa normalnych,
	\end{itemize}
	\item identyfikator materiału.
\end{itemize}

Metoda \textit{add\_material()} tworzy materiał w sposób analogiczny do metody \textit{add\_texture()}.

Dostęp do materiałów w shaderach odbywa się poprzez użycie identyfikatora materiału do indeksowania tablicy \textit{materials} w danych globalnych ujednoliconego bufora stałych.
Listing \ref{textureMaterialSampling} przedstawia przykładowy sposób dostępu do materiału podczas renderowania przykładowej sceny.
\lstset{language=GLSL}
\begin{lstlisting}[caption={Przykład dostępu do materiału podczas renderowania przykładowej sceny},captionpos=b,label={textureMaterialSampling}]
	uint globalIdx = getGlobalIdx();
	uint instanceId = getInstanceId();
	uint materialId = getMaterialId(instanceId);
	vec4 baseColorFactor = global[globalIdx].materials[materialId].baseColorFactor;
	uint baseColorTextureId = global[globalIdx].materials[materialId].baseColorTextureId;
	vec4 baseColorSample = texture(textures2D[baseColorTextureId], inTexCoord);
\end{lstlisting} 

 
\subsubsection{Deskryptory descriptors}
Obiekt \textit{descriptors} reprezentuje deskryptory udostępniające przebiegom renderowania tekstury i jednolity bufor stałych. Obiekt zarządza też stałymi push.

Obiekt zawiera wskaźniki do obiektów \textit{textures} i \textit{unified\_constant\_buffer} używanych do tworzenia i aktualizacji obiektów Vulkan pozwalających na użycie deskryptorów:
\begin{itemize}
	\item pula deskryptorów \textit{VkDescriptorPool},
	\item układ zbioru deskryptorów \textit{VkDescriptorSetLayout},
	\item zbiór deskryptorów \textit{VkDescriptorSet},
	\item układ potoku \textit{VkPipelineLayout}.
\end{itemize} 

Zgodnie z duchem renderowania bez dowiązań tworzony jest jeden globalny zbiór deskryptorów mający trzy dowiązania. Dwa pierwsze dowiązania zawierają pojedyncze deskryptory buforów uniform opisujące fragmenty jednolitego bufora stałych zawierające dane instancji i dane globalne. 
Ostatnie dowiązanie zawiera nieograniczoną tablicę tekstur.

Metoda \textit{send\_to\_device()} aktualizuje każde dowiązanie zbioru deskryptorów wywołaniami funkcji \textit{vkUpdateDescriptorSets()}.

Metoda \textit{record\_bind\_commands()} dowiązuje zbiór deskryptorów poleceniem \textit{vkCmdBindDescriptorSets()} oraz nagrywa wejściowe stałe push poleceniem \textit{vkCmdPushConstants()}.



\subsubsection{Shader}

Obiekt \textit{shader} reprezentuje pojedynczy shader i jest odpowiedzialny za kompilację ich do formy używalnej przez Vulkan.

Obiekt składa się z następujących elementów:
\begin{itemize}
	\item typ shadera,
	\item kod źródłowy GLSL,
	\item kod bajtowy SPIR-V,
	\item moduł shadera \textit{vkShaderModule},
	\item obiekt \textit{shader\_reflect}.
\end{itemize}

Typ shadera zależy od tego, dla którego etapu potoku graficznego jest on przeznaczony.
Wspierane są dwa typy: wierzchołków i fragmentów.

Kod źródłowy GLSL musi być znany podczas tworzenia - jest on uzyskiwany poprzez użycie obiektu \textit{shader\_generator} z modułu renderowania.

Kod bajtowy SPIR-V jest uzyskiwany poprzez kompilację kodu źródłowego GLSL biblioteką \textit{shaderc}, której użycie ilustruje listing \ref{shadercExample}.
\lstset{language=C}
\begin{lstlisting}[caption={Kompilacja kodu źródłowego GLSL biblioteką \textit{shaderc}},captionpos=b,label={shadercExample}]
shaderc_compiler_t compiler = shaderc_compiler_initialize();

shaderc_compile_options_t options = shaderc_compile_options_initialize();
shaderc_compile_options_set_target_env(options, shaderc_target_env_vulkan, 0);

const char *glslCode = ...;
size_t glslLen = strlen(glslCode);
shaderc_shader_kind shaderType = ...;
const char *inputFileName = "shader";
const char *entryPointName = "main";
shaderc_compilation_result_t result = shaderc_compile_into_spv(
compiler, glslCode, glslLen,
shaderType, inputFileName, entryPointName, NULL);
shaderc_compile_options_release(options);

if (shaderc_result_get_num_errors(result)) {
	const char *errorMsg = shaderc_result_get_error_message(result);
	panic("compilation error: %s\n", errorMsg);
}

size_t spvSize = shaderc_result_get_length(result);
uint32_t *spvCode = (uint32_t *)malloc(spvSize);
core_memcpy(spvCode, (uint32_t *)shaderc_result_get_bytes(result), spvSize);

shaderc_result_release(result);
shaderc_compiler_release(compiler)
\end{lstlisting}

Moduł shadera jest uzyskiwany poprzez kompilację kodu bajtowego SPIR-V funkcją vkCreateShaderModule(), który jest też używany do uzyskania obiektu \textit{shader\_reflect}.

Obiekt \textit{shader\_reflect} reprezentuje mechanizm refleksji shadera pozwalający na badanie jego struktury.
Operuje on na kodzie bajtowym SPIR-V i jest on używany podczas testów oraz do logowania informacji debugujących.



\subsubsection{Synchronizacja sync}
Obiekt \textit{sync} zawiera obiekty Vulkan które są używane do renderowania klatek w locie, ale nie mogą być pomiędzy nimi współdzielone i muszą być przetrzymywane w tablicach zawierających \textit{FRAMES\_IN\_FLIGHT} kopii.
Są to:
\begin{itemize}
	\item semafory \textit{imageAvailableSemaphores} sygnalizujące, że prezentowalny obraz zwrócony przez funkcję \textit{vkAcquireNextImageKHR()} jest gotowy do renderowania;
	\item semafory \textit{renderFinishedSemaphores} sygnalizujące, że wykonywany bufor zakończył renderowanie do prezentowalnego obrazu, który może zostać zaprezentowany funkcją \textit{vkQueuePresentKHR()};
	\item ogrodzenia \textit{inFlightFences} sygnalizowane po zakończeniu renderowania klatki i używane do ograniczenia ich liczby do \textit{FRAMES\_IN\_FLIGHT} jednocześnie renderowanych klatek;
	\item pule poleceń i bufory poleceń, które są równolegle nagrywane i wysyłane do kolejki w pętli głównej programu.
\end{itemize}

Pole \textit{currentFrameInFlight} jest indeksem używanym do śledzenia która kopia powinna być używana w obecnej klatce.
Metoda \textit{advance\_to\_next\_frame()} wywoływana na początku klatki inkrementuje \textit{currentFrameInFlight} i dzieli modulo \textit{FRAMES\_IN\_FLIGHT}.



\subsection{Scena}

Moduł sceny jest odpowiedzialny za konwersję sceny z danych sceny \textit{scene\_data} do pamięci podręcznej renderera \textit{renderer\_cache} - wysokopoziomowa forma używanej przez bazę zasobów jest zamieniana na niskopoziomową formy łatwo używalnej przez renderer do emitowania poleceń rysowania pośredniego.

Obiekty biorące udział w procesie konwersji sceny są przedstawione na diagramie \ref{scene_process}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=0.5cm]
		\tikzstyle{entity} = [rectangle, minimum width=3cm, minimum height=0.5cm,text centered, draw=black]
		\tikzstyle{flows} = [thick,->,>=stealth]
		
		\node (scene_data) [entity] {scene\_data};
		\node (scene_graph) [entity, below = of scene_data] {scene\_graph};
		\node (scene_tree) [entity, below = of scene_graph] {scene\_tree};
		\node (renderer_cache) [entity, below = of scene_tree] {renderer\_cache};
		
		\node (scene_graph_node) [entity, right = of scene_graph] {scene\_graph\_node};
		\node (scene_graph_node_dots) [right = 1mm of scene_graph_node] {...};
		\node (scene_tree_node) [entity, right = of scene_tree] {scene\_tree\_node};
		\node (scene_tree_node_dots) [right = 1mm of scene_tree_node] {...};
		
		\node (renderer_cache_primitive_element) [entity, below = of renderer_cache] {renderer\_cache\_primitive\_element};
		\node (renderer_cache_primitive_element_dots) [right = 1mm of renderer_cache_primitive_element] {...};
		\node (renderer_cache_camera_element) [entity, below = of renderer_cache_primitive_element] {renderer\_cache\_camera\_element};
		\node (renderer_cache_camera_element_dots) [right = 1mm of renderer_cache_camera_element] {...};
		\node (renderer_cache_direct_light_element) [entity, below = of renderer_cache_camera_element] {renderer\_cache\_direct\_light\_element};
		\node (renderer_cache_direct_light_element_dots) [right = 1mm of renderer_cache_direct_light_element] {...};
		\node (renderer_cache_skybox_element) [entity, below = of renderer_cache_direct_light_element] {renderer\_cache\_skybox\_element};
		\node (renderer_cache_skybox_element_dots) [right = 1mm of renderer_cache_skybox_element] {...};
		\node(renderer_cache_elements)[draw,dotted,fit=(renderer_cache_primitive_element) (renderer_cache_camera_element) (renderer_cache_direct_light_element) (renderer_cache_skybox_element) (renderer_cache_direct_light_element_dots)] {};
		
		\node (vkCmdDrawIndexedIndirect) [entity, right = of renderer_cache_elements] {vkCmdDrawIndexedIndirect()};
		
		\draw [flows] (scene_data) edge[out=-90,in=90] (scene_graph);
		\draw [flows] (scene_graph) edge[out=180,in=180] (renderer_cache);
		\draw [flows] (scene_graph) edge[out=-90,in=90] (scene_tree);
		\draw [flows] (scene_graph) edge[] (scene_graph_node);
		\draw [flows] (scene_graph_node) edge[] (scene_tree_node);
		\draw [flows] (scene_tree) edge[out=-90,in=90] (renderer_cache);
		\draw [flows] (scene_tree) edge[] (scene_tree_node);
		\draw [flows] (renderer_cache) edge[] (renderer_cache_elements);
		\draw [flows] (renderer_cache_elements) edge[] (vkCmdDrawIndexedIndirect);
		
	\end{tikzpicture}
	\caption{Obiekty biorące udział w procesie konwersji sceny (opracowanie własne)}
	\label{scene_process}
\end{figure}

\subsubsection{Dane sceny scene\_data}
Obiekt \textit{scene\_data} reprezentuje dane sceny wczytane z bazy zasobów. Jest one używany przez moduł sceny do konstrukcji grafu sceny \textit{scene\_graph}.

Obiekt utrzymuje listy dwukierunkowe zawierającą wszystkie utworzone obiekty zasobów, w tym ich domyślne warianty.
Przykładowo domyślny obraz \textit{asset\_image} to obraz 2D o rozmiarze 1x1 mający 4 8-bitowe komponenty o wartości 255.

Wśród wszystkich obiektów zasobów składających się na dane sceny dodatkowo wyróżnia się:
\begin{itemize}
	\item węzły główne: używane jako punkty początkowe podczas tworzenia grafu sceny,
	\item używany skybox: może być zmieniony w konfiguracji zasobów,
	\item aktywna czcionka: sterowana konfiguracją globalną,
	\item domyślna kamera: używana w przypadku braku węzła z przypisaną kamerą.
\end{itemize}

Metody \textit{serialize()} i \textit{deserialize()} podobnie jak analogiczne metody obiektów zasobów pozwalają na zapis i odczyt danych sceny do bazy zasobów.

Metoda \textit{create\_with\_gltf\_file()} jest wywoływana wyłącznie przez potok zasobów.
Jej wejściem jest nazwa tworzonej sceny i ścieżka do katalogu zawierającego zasób 3D w formacie \textit{glTF} wraz z konfiguracją zasobów.
Oba zasoby wejściowe są parsowane przy użyciu biblioteki \textit{cgltf} i obiektu \textit{config}.
Wynik parsowania jest używany do stworzenia i wypełnienia danych sceny.
Ta metoda wraz z metodą \textit{serialize()} stanowi główną częścią potoku zasobów - obiekt stworzony na podstawie zasobów wejściowych jest serializowany do zasobu wyjściowego (bazy zasobów).

Metoda \textit{create\_with\_asset\_db()} jest wywoływana w czasie wykonywania i wczytuje dane sceny o żądanej nazwie z bazy zasobów.

\subsubsection{Graf sceny scene\_graph i drzewo sceny scene\_tree}
Obiekty \textit{scene\_graph} i \textit{scene\_tree} reprezentują kolejno graf i drzewo sceny.
Są one tworzone na podstawie danych sceny używając metody \textit{create\_with\_scene\_data()}.

Implementacja została zainspirowana techniką modelowania hierarchicznego opracowaną w firmie Nvidia \cite{ADVANCEDSCENEGRAPH}.
Graf sceny jest konwertowany na formę pośrednią zwaną drzewem sceny w sposób zapewniający unikalną ścieżkę z korzenia drzewa do jego liści.
Uprasza to klasyczny proces konwersji sceny algorytmem \ref{RenderujGrafSceny} - podczas przechodzenia drzewa sceny każdy węzeł może być napotkany tylko raz.
Właściwość ta pozwala na wprowadzenie do węzła stanu nagromadzonego (struktura \textit{scene\_tree\_node\_accumulated}) zawierającego aktualny wynik działania algorytmu.
Konwersja sceny sprowadza się wtedy do całkowitej propagacji stanu nagromadzonego od korzenia do liści, w których jest on całkowicie wypełniony i tym samym zawiera wszystkie informacje wymagane do wyemitowania polecenia rysowania.

Diagramy \ref{triangles_scene_graph} i \ref{triangles_scene_tree} przedstawiają wygenerowane metodami \textit{debug\_print()} graf i drzewo sceny składającej się z dwóch trójkątów używających tej samej siatki, ale różniących się pozycją.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{images/scene_graph.png}
	\caption{Przykładowy graf sceny zawierającej dwa trójkąty (opracowanie własne)}
	\label{triangles_scene_graph}
\end{figure}
Graf sceny składa się z czterech węzłów \textit{scene\_graph\_node}: korzenia oraz dwóch węzłów utworzonych na podstawie zasobów obiektów wskazujących na ten sam węzeł z zasobem prymitywu.
Węzły grafu sceny obserwują utworzone na ich podstawie podczas procesu konwersji węzły drzewa sceny, co pozwala na aktualizację i propagację ich stanu nagromadzonego po zmianach w węźle grafu sceny bez konieczności całkowitego odtworzenia drzewa sceny.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{images/scene_tree.png}
	\caption{Przykładowe drzewo sceny zawierającej dwa trójkąty (opracowanie własne)}
	\label{triangles_scene_tree}
\end{figure}
Drzewo sceny składa się z pięciu węzłów \textit{scene\_tree\_node} posiadających stan nagromadzony:
\begin{itemize}
	\item korzeń: stan posiada lokalnym przekształceniem będącym macierz obrotu zmieniająca prawoskrętną przestrzeń modelu glTF na lewoskrętną przestrzeń używaną przez silnik;
	\item dwa węzły utworzone na podstawie węzłów z zasobami obiektów: stan posiada lokalne przekształcenie zmieniające pozycję trójkątów;
	\item dwa liście utworzone na podstawie węzłów z zasobami prymitywu: stan posiada wskaźnik do zasobu prymitywu.
\end{itemize}
Po zakończeniu propagacji stanu nagromadzonego liście posiadają informacje o prymitywie i jego globalnym przekształceniu.
Liście drzewa sceny są dodawane do pamięci podręcznej renderera.


\subsection{Renderer}

Główny moduł silnika odpowiedzialny za właściwy proces renderowania.
Moduł renderera jest używany do zaimplementowania aplikacji renderującej przykładową scenę.


\subsubsection{Renderer}
Obiekt \textit{renderer} to główny obiekt modułu odpowiedzialny za integrację wszystkich obiektów silnika w celu rozpoczęcia pętli głównej programu i wyrenderowanie sceny.
Obiekt tworzy i używa następujące obiekty:
\begin{itemize}
	\item konfiguracja globalna \textit{data\_config},
	\item baza zasobów \textit{asset\_db},
	\item dane sceny \textit{scene\_data},
	\item graf sceny \textit{scene\_graph},
	\item pamięć podręczna renderowania \textit{renderer\_cache},
	\item urządzenie \textit{device},
	\item łańcuch wymiany \textit{swap\_chain},
	\item stan renderera \textit{render\_state},
	\item graf renderowania \textit{render\_graph}.
\end{itemize}

Po stworzeniu obiektu aplikacja musi skonstruować i skompilować początkowo pusty graf renderowania.
Następnie może ona rozpocząć pętlę główną programu metodą \textit{run\_main\_loop()}, która renderuje pojedyncza klatkę w locie używając następujących kroków:
\begin{itemize}
	\item zaktualizuj stan renderera wejściową funkcją zwrotną \textit{updateFunc};
	\item czekaj aż ogrodzenie \textit{inFlightFences} obecnej klatki w locie zasygnalizuje zakończenie wykonywania poprzednio nagranego bufora poleceń i gotowość do ponownego nagrywania;
	\item pobierz prezentowalny obraz funkcją \textit{vkAcquireNextImageKHR()};
	\item odtwórz łańcuch wymiany jeśli jest nieaktualny i pomiń resztę iteracji pętli;
	\item zaktualizuj i skopiuj do GPU stan renderera i graf renderowania używając ich metod \textit{update()} i \textit{send\_to\_device()};
	\item zresetuj bufor poleceń i rozpocznij nagrywanie;
	\item dowiąż stan renderera (jednolite bufory, zbiór deskryptorów i stałe push);
	\item nagraj przebiegi renderowania używając grafu renderowania;
	\item zakończ nagrywania;
	\item wyślij bufor poleceń do kolejki graficznej funkcją \textit{vkQueueSubmit()} zapewniając synchronizację poprzez oczekiwanie na semafor \textit{imageAvailableSemaphores} oraz sygnalizację semafor \textit{renderFinishedSemaphores} i zresetowanego ogrodzenia \textit{inFlightFences};
	\item prezentuj wynik renderowania funkcją \textit{vkQueuePresentKHR()} zapewniając synchronizację poprzez oczekiwanie na semafor \textit{renderFinishedSemaphores}
	\item odtwórz łańcuch wymiany jeśli jest nieaktualny;
	\item przejdź do kolejnej klatki w locie (metoda \textit{advance\_to\_next\_frame()} obiektu \textit{sync}).
\end{itemize}

W dalszych sekcjach przybliżono obiekty renderera i używającą go przykładową aplikację.


\subsubsection{Pamięć podręczna renderera renderer\_cache}
Pamięć podręczna renderera \textit{renderer\_cache} jest niskopoziomową reprezentacją sceny pośredniczącą pomiędzy modułami sceny i renderera.
Obiekt jest podstawowym źródłem informacji o scenie używanym przez resztę obiektów modułu.

Inicjalizację pamięci podręcznej renderera można podzielić na dwie fazy - graf sceny wypełniania obiekt informacjami o scenie, który jest następnie używany do wypełnienia obiektów używanych przez renderer:
\begin{itemize}
	\item stan renderera,
	\item stany przebiegów renderowania,
	\item grup poleceniami rysowania.
\end{itemize}

Obiekt jest złożony z list elementów \textit{renderer\_cache\_*\_element}:
\begin{itemize}
	\item \textit{renderer\_cache\_primitive\_element}: element prymitywu;
	\item \textit{renderer\_cache\_camera\_element}: element kamery;
	\item \textit{renderer\_direct\_light\_element}: element światła bezpośrednie;
	\item \textit{renderer\_skybox\_element}: element skybox;
	\item \textit{renderer\_font\_element}: element czcionki.
\end{itemize}
Elementy są dodawane przez graf sceny używając metod \textit{add\_*\_element()}.

Obiekt jest używany do aktualizacji stanu renderera:
\begin{itemize}
	\item Metoda \textit{update\_geometry()} dodaje geometrię prymitywów do jednolitego bufora geometrii.
	\item Metoda \textit{update\_textures()} dodaje tekstury używane przez elementy do tekstur \textit{textures}.
\end{itemize}

\item Metoda \textit{add\_new\_primitive\_elements\_to\_batches()} dodaje polecenia rysowania prymitywów do grup poleceniami rysowania.

Aktualizacja stanu renderera i grup poleceń rysowania przy użyciu powyższych metod jest odzwierciedlana aktualizacją stanu elementu.
Przykładowo wywołanie metody \textit{update\_geometry()} aktualizuje strukturę \textit{vertex\_stream\_element} elementów prymitywów offsetami buforów strumienia wierzchołków.
Podobnie metoda \textit{update\_textures()} dodaje tekstury elementu skybox, których identyfikatory są zapamiętywane w elementach.

Zachowanie to pozwala stanom przebiegów renderowania na aktualizację jednolitego bufora stałych informacjami o scenie.
Przykładowo element skybox jest używany do aktualizacji zmiennej \textit{skyboxCubemapTextureId} używanej przez shadery renderujące skybox.


\subsubsection{Grupy poleceń rysowania batches}
Grupa poleceń rysowania \textit{batches} reprezentuje jedno optymalizowane polecenia rysowania utworzone na podstawie elementów prymitywów dodanych metodą \textit{add\_primitive\_element()}.

Metoda \textit{update()} sortuje i konsoliduje dodane elementy prymitywów tworząc tablicę pojedynczych grup poleceń rysowania \textit{batch}.
Pojedyncza grupa poleceń \textit{batch} zawiera wszystkie informacje wymagane do nagrania pojedynczego polecenia rysowania \textit{vkCmdDrawIndexed()} rysującego $n$ kopii mających tą samą geometrię, ale różniących się materiałem i macierzą modelu.

Metoda \textit{record\_draw\_command()} nagrywa do wejściowego bufora poleceń pojedyncze polecenie wielokrotnego rysowania pośredniego \textit{vkCmdDrawIndexedIndirect}, której bufora parametrów jest wypełniany wcześniej stworzoną tablicą obiektów \textit{batch}.
Bufor parametrów jest przekazywany do metody strukturą \textit{batches\_buffer}, która jest zarządzana przez stan przebiegów renderowania.


\subsubsection{Stan renderera renderer\_state i stan przebiegów renderowania render\_pass\_state}
Stan renderera \textit{renderer\_state} zawiera wszystkie obiekty renderera, które są niezależne od stanu przebiegów renderowania.
Są to:
\begin{itemize}
	\item strumień wierzchołków \textit{vertex\_stream},
	\item jednolity bufor geometrii \textit{unified\_geometry\_buffer} (dane globalne współdzielone przez klatki w locie),
	\item tekstury \textit{textures},
	\item jednolity bufor stałych \textit{unified\_constant\_buffer},
	\item deskryptory \textit{descriptors},
	\item synchronizacja \textit{sync}.
\end{itemize}

Podział ten jest spowodowany obsługą odtwarzania łańcucha wymiany - większość stanu przebiegów renderowania, w przeciwieństwie od stanu renderera, zależy od wielkości łańcucha wymiany i dlatego musi być niszczony i ponownie tworzony przez renderer wraz z łańcuchem wymiany.

Metody \textit{update()} i \textit{send\_to\_device()} wywołuje analogiczne metody obiektów renderera.

Stan przebiegów renderowania \textit{render\_pass\_state} jest obiektem analogicznym do stanu renderera i odpowiada za aktualizację jednolitego bufora stałych (dane instancji oraz dane globalne zależne od obecnej klatki w locie) oraz zarządzanie buforami parametrów poleceń rysowania pośredniego.


\subsubsection{Graf renderowania render\_graph}
Graf renderowania \textit{render\_graph} opisuje proces renderowania klatki w formie przebiegów renderowania i używanych przez nie obrazów.
Obiekt jest też odpowiedzialny za zarządzanie wszystkimi przebiegami renderowania \textit{render\_pass} i współdzielonym przez nie stanem przebiegów renderowania \textit{render\_pass\_state}.

Metoda \textit{add\_image\_resource()} jest używana przez aplikację do dodania wszystkich obrazów, które będą używane przez przebiegi renderowania. Wyjątkiem są prezentowalne obrazy, które są dodawane automatycznie.

Dodane obrazy są przechowywane w liście struktur \textit{render\_graph\_resource} posiadającej:
\begin{itemize}
	\item nazwę zasobu;
	\item typ obrazu;
	\item identyfikator tekstury pozaekranowej: obsługa klatek w locie wymaga wewnętrznej duplikacji używanych tekstury pozaekranowych, dlatego indeks obrazu należącego do obecnej klatki jest przekazywany w jednolitym buforze stałych do shaderów chcących je próbkować;
	\item harmonogram użycia \textit{image\_render\_pass\_usage\_timeline}
\end{itemize}

Harmonogram użycia obrazu \textit{image\_render\_pass\_usage\_timeline} opisuje sposób użycia (odczyt, zapis, odczyt i zapis), format i wartość czyszczenia obrazu na wskroś przebiegów renderowania.
Jest on wypełniony podczas kompilacji i używany do nagrania wymaganych przejść układów obrazów pomiędzy przebiegami renderowania.

Listing \ref{render_graph_images} przedstawia kod przykładowej aplikacji dodający obrazy (G-bufor, bufor głębi i bufor okluzji otoczenia) do grafu renderowania.
\lstset{language=C}
\begin{lstlisting}[caption={Dodawanie obrazów do grafu renderowania przykładowej aplikacji},captionpos=b,label={render_graph_images}]
render_graph_add_image_resource(renderer->renderGraph, "depthBuffer",
image_type_offscreen_depth_buffer);
render_graph_add_image_resource(renderer->renderGraph, "gBuffer0", image_type_offscreen_f16);
render_graph_add_image_resource(renderer->renderGraph, "gBuffer1", image_type_offscreen_f16);
render_graph_add_image_resource(renderer->renderGraph, "gBuffer2", image_type_offscreen_f16);
render_graph_add_image_resource(renderer->renderGraph, "aoBuffer", image_type_offscreen_r8);
\end{lstlisting}

Metoda \textit{add\_render\_pass()} jest używana przez aplikację do dodawania następujących po sobie przebiegów renderowania opisywanych strukturą \textit{render\_pass\_desc}.

Dodane przebiegi renderowania są przechowywane jako węzły grafu renderowania \textit{render\_graph\_render\_pass\_element} posiadające:
\begin{itemize}
	\item przebieg renderowania \textit{render\_pass};
	\item wskaźniki do zasobów \textit{render\_graph\_resource}, które będą używane przez przebieg renderowania:
	\begin{itemize}
		\item prezentowalny obraz: dołączenie koloru);
		\item tekstury pozaekranowe: dołączenia koloru lub próbkowany przez shader);
		\item bufor głębi: dołączenie głębi/szablonu używane do testów głębi z możliwością aktualizacji lub próbkowany przez shader;
	\end{itemize}
	\item stan kompilacji: struktura \textit{rendering\_info} używana nagrania przejść układów powyższych obrazów i rozpoczęcia przebiegu renderowania poleceniem \textit{vkCmdBeginRenderingKHR()}.
\end{itemize}
Wszystkie powyższe obiekty są tworzone na podstawie opisu przebiegu renderowania \textit{render\_pass\_desc}. Listing \ref{render_graph_deferred_geometry} przedstawia kod przykładowej aplikacji dodający przebieg geometrii, który:
\begin{itemize}
	\item używa shadera wierzchołków \textit{deferred\_geometry\_vertex.glsl};
	\item używa shadera fragmentów \textit{deferred\_geometry\_fragment.glsl};
	\item nie renderuje do prezentowalnego obrazu;
	\item używa trzech obrazów G-bufora, które są czyszczone wartością $0,0,0,1$ jeśli są używane po raz pierwszy oraz używane jako dowiązania kolorów;
	\item używa bufora głębi jako dołączenia głębi/szablonu, czyszczonego wartością $0,0$, używanego do testów głębi z operatorem porównania "większy lub równy" i włączonym zapisem;
	\item brak mieszania kolorów;
	\item nagrywa zoptymalizowane polecenie rysowania wszystkich elementów prymitywów podręcznej pamięci renderera.
\end{itemize}
\lstset{language=C}
\begin{lstlisting}[caption={Dodawanie przebiegu geometrii do grafu renderowania przykładowej aplikacji},captionpos=b,label={render_graph_deferred_geometry}]

void render_pass_record_primitive_geometry_draws(render_pass *renderPass, render_pass_frame_state *frameState, VkCommandBuffer commandBuffer) {
	batches_record_draw_command(renderPass->renderPassState->sharedState.rendererCacheBatches,
	commandBuffer, &frameState->rendererCacheBatchesData);
}

render_graph_add_render_pass(renderer->renderGraph, (render_pass_desc){
	.vertexShader = "deferred_geometry_vertex.glsl",
	.fragmentShader = "deferred_geometry_fragment.glsl",
	.useOnscreenColorAttachment = false,
	.offscreenColorAttachmentCount = 3,
	.offscreenColorAttachments =
	{
		{.name = "gBuffer0", .clearValue = {{0.0f, 0.0f, 0.0f, 1.0f}}},
		{.name = "gBuffer1", .clearValue = {{0.0f, 0.0f, 0.0f, 1.0f}}},
		{.name = "gBuffer2", .clearValue = {{0.0f, 0.0f, 0.0f, 1.0f}}},
	},
	.offscreenDepthAttachment =
	{
		.name = "depthBuffer",
		.depthWriteEnable = true,
		.depthTestEnable = true,
		.depthTestOp = VK_COMPARE_OP_GREATER_OR_EQUAL,
		.clearValue = {0.0f, 0.0f},
	},
	.colorBlendingType = color_blending_type_none,
	.recordFunc = render_pass_record_primitive_geometry_draws});
\end{lstlisting}

Metoda \textit{compile()} kompiluje graf renderowania.
Dla każdego węzła metoda oblicza harmonogramy użycia dla używanych przez niego obrazów i następnie używa ich do wypełnienia stanu kompilacji celami renderowania z wymaganymi przez nie przejściami układów obrazów.

Metoda \textit{record\_commands()} iteruje po węzłach używając ich stanu kompilacji do nagrania przebiegów renderowania.

Metody \textit{update()} i \textit{send\_to\_device()} aktualizuje i kopiuje do GPU stan przebiegów renderowania.


\subsubsection{Przebieg renderowania render\_pass}
Przebieg renderowania \textit{render\_pass} jest tworzony na podstawie opisu przebiegu renderowania \textit{render\_pass\_desc} i składa się z:
\begin{itemize}
	\item potoku graficznego \textit{VkPipeline},
	\item programu shaderów \textit{render\_pass\_shader\_program};
\end{itemize}

Potok graficzny jest tworzony na podstawie opisu \textit{render\_pass\_desc} oraz stanu renderowania (stan wejścia wierzchołków zależny od \textit{vertex\_stream}).
Moduły shaderów używane przez potok są tworzone przez program shaderów wywołujący generator shaderów \textit{render\_pass\_shader\_generator}.

Metoda \textit{record()} nagrywa dynamiczny przebieg renderowania z dowiązanym potokiem graficznym i poleceniami rysowania zdefiniowanymi polem \textit{recordFunc} opisu \textit{render\_pass\_desc}.


\subsubsection{Generator shaderów render\_pass\_shader\_generator}
Generator shaderów \textit{render\_pass\_shader\_generator} generuje kod źródłowy GLSL pojedynczego shadera.

Generacja kodu źródłowego sprowadza się do konkatenacji:
\begin{itemize}
	\item dyrektyw preprocesora deklarujących używane rozszerzenia,
	\item stałych preprocesora opisujących:
	\begin{itemize}
		\item używane atrybuty wierzchołka (\textit{IN\_POSITION}, \textit{IN\_NORMAL} itp.),
		\item typ shadera (\textit{SHADER\_VERTEX}, \textit{SHADER\_FRAGMENT}),
		\item wygenerowane stałe (np. \textit{MAX\_DIRECTIONAL\_LIGHT\_COUNT}),
		\item nazwy używanych tekstur pozaekranowych (np. \textit{OFFSCREEN\_TEXTURE\_gBuffer1}),
	\end{itemize}
	\item kwalifikatorów układów dla stałych push, buforów uniform i tablicy tekstur,
	\item zmiennych wejściowych i wyjściowych,
	\item współdzielonego kodu GLSL wczytanego z pliku tekstowego \textit{common.glsl},
	\item funkcji \textit{main()}:
	\begin{itemize}
		\item zmienne z indeksami tekstur pozaekranowych,
		\item kod GLSL wczytany z pliku tekstowego zdefiniowanego w opisie \textit{render\_pass\_desc}.
	\end{itemize}
\end{itemize}


\subsubsection{Przykładowa scena main}
Plik wykonywalny \textit{main} demonstruje działanie silnika poprzez wyrenderowanie sceny zdefiniowanej w konfiguracji globalnej używając grafu renderowania.

Diagram \ref{render_graph_final} przedstawia używany graf renderowania opisujący cieniowane odroczone zintegrowane z okluzję otoczenia \cite{PureDepthSSAO} i dwoma dodatkowymi efektami post-processingu: skybox i tekst debugujący.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=1cm]
		\tikzstyle{pass} = [rectangle, minimum width=3.5cm, minimum height=1cm,text centered, draw=black]
		\tikzstyle{resource} = [rectangle, rounded corners, minimum width=3.5cm, minimum height=1cm, text centered, draw=black]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		\tikzstyle{relation} = [densely dotted,->]
		
		\node (gBuffor2) [resource] {Obraz G-bufor \#2};
		\node (gBuffor1) [resource, above = 6mm of gBuffor2] {Obraz G-bufor \#1};
		\node (gBuffor3) [resource, below = 6mm of gBuffor2] {Obraz G-bufor \#3};
		\node (depthResource) [resource, below = 6mm of gBuffor3] {Bufor głębi};
		\node (aoResource) [resource, below = 6mm of depthResource] {Bufor AO};
		\node (presentableImage) [resource, below = 6mm of aoResource] {Prezentowalny obraz};
		
		\node (geometryPass) [pass, right = 3cm of gBuffor1] {Przebieg geometrii};
		\node (aoPass) [pass, below = of geometryPass] {Okluzja otoczenia};		
		\node (lightingPass) [pass, below = of aoPass] {Przebieg oświetlenia};
		\node (skyboxPass) [pass, below = of lightingPass] {Skybox};
		\node (debugTextPass) [pass, below = of skyboxPass] {Tekst debugowania};
		
		\draw [relation] (geometryPass) edge (aoPass);
		\draw [relation] (aoPass) edge (lightingPass);
		\draw [relation] (lightingPass) edge (skyboxPass);
		\draw [relation] (skyboxPass) edge (debugTextPass);
		
		\draw [arrow] (geometryPass) edge[out=180-10,in=0,looseness=0] (gBuffor1);
		\draw [arrow] (geometryPass) edge[out=180-5,in=0,looseness=0] (gBuffor2);
		\draw [arrow] (geometryPass) edge[out=180+0,in=0+5,looseness=0] (gBuffor3);
		\draw [arrow] (geometryPass) edge[out=180+5,in=0+10,looseness=0] (depthResource);
		
		\draw [arrow] (gBuffor1) 		edge[out=0-5,in=180-10,looseness=0] (aoPass);
		\draw [arrow] (gBuffor3) 		edge[out=0,in=180-5,looseness=0] (aoPass);
		\draw [arrow] (depthResource) 	edge[out=0+5,in=180+0,looseness=0] (aoPass);
		\draw [arrow] (aoPass) 			edge[out=180+5,in=0+5,looseness=0] (aoResource);
		
		\draw [arrow] (gBuffor1) edge[out=0-10,in=180-10,looseness=0] (lightingPass);
		\draw [arrow] (gBuffor2) edge[out=0,in=180-5,looseness=0] (lightingPass);
		\draw [arrow] (gBuffor3) edge[out=0-5,in=180+0,looseness=0] (lightingPass);
		\draw [arrow] (depthResource) edge[out=0,in=180+5,looseness=0] (lightingPass);
		\draw [arrow] (aoResource) edge[out=0,in=180+10,looseness=0] (lightingPass);
		\draw [arrow] (lightingPass) edge[out=180+15,in=0+10,looseness=0] (presentableImage);
		
		\draw [arrow] (depthResource) edge[out=0-5,in=180-5,looseness=0] (skyboxPass);
		\draw [arrow] (presentableImage) edge[out=0+5,in=180+0,looseness=0] (skyboxPass);
		\draw [arrow] (skyboxPass) edge[out=180+5,in=0,looseness=0] (presentableImage);
		
		\draw [arrow] (presentableImage) edge[out=0-5,in=180-5,looseness=0] (debugTextPass);
		\draw [arrow] (debugTextPass) edge[out=180+5,in=0-10,looseness=0] (presentableImage);
		
	\end{tikzpicture}
	\caption{Graf renderowania przykładowej sceny (opracowanie własne)}
	\label{render_graph_final}
\end{figure}

Listing \ref{main_final} przedstawia kod funkcji \textit{main()} przykładowej aplikacji uruchamiający renderer.
\lstset{language=C}
\begin{lstlisting}[caption={Uruchomienie renderera w funkcji \textit{main()} przykładowej aplikacji},captionpos=b,label={main_final}]
void render_pass_record_draws(render_pass *renderPass, render_pass_frame_state *frameState, VkCommandBuffer commandBuffer) {
	batches_record_draw_command(renderPass->renderPassState->sharedState.rendererCacheBatches, commandBuffer, &frameState->rendererCacheBatchesData);
}

void update_func(renderer *renderer, double fps, double dt) {
	device *vkd = renderer->vkd;
	render_state *renderState = renderer->renderState;
	if (renderState->config->global.controlsEnabled == 1) { ... }
}

int main(int argc, char *argv[]) {
	platform_create(argc, argv);
	renderer *renderer = renderer_create();
	
	render_graph_add_image_resource(renderer->renderGraph, "gBuffer0", image_type_offscreen_f16);
	...
	render_graph_add_render_pass(
		renderer->renderGraph,
		(render_pass_desc){
			...
			.recordFunc = render_pass_record_primitive_geometry_draws
		}
	);
	...
	
	renderer_run_main_loop(renderer, update_func);
	
	renderer_destroy(renderer);
	platform_destroy();
	return 0;
}
\end{lstlisting}

