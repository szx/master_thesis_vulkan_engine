Praca magisterska podzielona na dwie części:
Opis i analiza algorytmów graficznych i technik post-processingu używanych podczas renderowania sceny w nowoczesnych grach 3D (temat rzeka).

Vertex shader: animacje szkieletowa
Geometry shading: LOD - tworzenie nowej geometrii, usuwanie wierzchołków z odległej geometrii

render pass - mgliste
multi-pass rendering - ten sam obiekt jest renderowany kilka razy

    A geometry pass, where data needed for shading is written to the G-buffer (depth, albedo (difusse), normals).
    A lighting pass, where shading is performed using the information in the G-buffer.
    
Usuwanie niewidocznych powierzchni: view frustum culling (odrzucanie obiektów poza bryłą widzenia, nie wysylac geometrii do GPU), occlusion culling, podział przestrzeni (Binary Space Partitioning, Octtree drzewo ósemkowe i portale).

Obsługa przezroczystości: Order-independent transparency bardzo dokładne i wolne, zwykle sortowanie front-to-back dla nieprzeźroczystych (Z-culling w early-Z), sortowanie back-to-front i alpha blending dla półprzeźroczystych.
Techniki post-processingu: efekty nakładane po tym jak geometria jest wyrenderowana do obrazu 2d, HDR (high dynamic range, kolor fragmentu większe niż 1.0, tone mapping do 0.0-1.0), motion blur, bloom



Vulkan 1.2: styczeń 2020
VK_KHR_buffer_device_address: wskaźniki do buforów w shaderach


1. Ustawienie stanów renderowania (w tym tekstur, shaderów i parametrów przekazanych do shaderów)
2. Ustawienie aktywnego bufora wierzchołków, bufora indeksów
3. Uruchomienie metody renderującej

Kiedyś były display listy, ale od OpenGL 3 deprecated. Zmiana stanu jak np. blendingu wymaga patchowania fragment shadera po stronie sterownika.

Wielowątkowość w Vulkanie - trzy wątki dla trzech ramek (triple buffering) nagrywają bufory (command pool osobny dla każdego wątku). Kilka wątków może nawet submitować te bufory do GPU, z zastrzerzeniem, że muszą wykonywać się na różnych command queue (kolejkach komend), w OpenGL jest jeden wątek renderujący odpowiedzialny . 

Synchronizacja w Vulkanie: Semafory i fence dla command bufferów, pipeline barriery i eventy dla komend. execution barriers/memory barriers/image transition



# Praca magisterska - draft

1. Wybierz plik.
2. Definicja / Dlaczego / Co dokładnie robi. ...

TODO: wrong union in light, remove spot light, rename vertex component to vertex element, rename asset_image to
asset_bitmap, move asset/ outside vulkan/, remove MAX_FRAMEBUFFER_ATTACHMENT_COUNT, remove STORAGE_BUFFER, move checking
FILTER_LINEAR to image format params

What? Why? How? Nieporuszono: podział przestrzeni i culling, multisampling Zagadnienia: wieloplatformowość, automatyczna
generacja kodu, bazy danych Test: obrazy z HOST_VISIBlE Skróty: GPU, indirect rendering - pośrednie renderowania,
fixed-function, buffor, image, texture - sampled image, binding - dowiązanie, bindless rendering - renderowanie bez
dowiązań, update after bind - uaktualnienie po dowiązaniu tiling - kafelkowanie, texel, staging buffer - bufor
tymczasowy, MSAA, shader stage - etap cieniowania, shader invocation - wywołanie shadera, draw call - polecenie
rysowania, texture unit - jednostka teksturujące, device feature - funkcja urządzenia, instance feature - funkcja
instancji, sampler - próbnik sampled image - próbkowany obraz, frame - klatka, command buffer - bufor poleceń layout
qualifier - kwalifikator układu update-after-bind - aktualizacja po dowiązaniu variable-sized descriptor binding -
dowiązanie deskryptora o zmiennej wielkości render state - stan renderowania unified uniform buffer - ujednolicony bufor
uniform unified geometry buffer - ujednolicony bufor geometrii GLSL - OpenGL Shading Language swap chain - łańcuch
wymiany WSI - window system integration framebufer attachment - dołączenie bufora ramki front buffer - bufor przedni
back buffer - bufor tylni presentation engine - silnik prezentacji in-flight frame - klatka w locie, image layout
transition - przejście układu obrazu, execution dependency - zależność wykonania, memory dependency - zależność pamięci
storage buffer - bufor magazynowy

-------------

# 2. Podstawy teoretyczne

...

# 3. Implementacja

Ten rozdział przedstawia szczegóły implementacji poszczególnych elementów silnika.

## Założenia

Implementacji przyświacały następujące:
Niskopoziomowość. ...

## Struktura plików

Wszystkie pliki silnika znajduje się w jednym katalogu głównym.

Katalog główny jest podzielony na mniejsze podkatalogi:

- *assets*: zawierający pliki wejściowe potoku zasobów,
- *src*: kod źródłowy silnika dla języka C,
- *scripts*: kod źródłowy silnika dla języka Python,
- *thirdparty*: kod źródłowy bibliotek zewnętrznych.

Proces budowania stwarza dodatkowe podkatalogi tymczasowe:

- *venv*: środowisko wirtualne interpretera języka Python,
- *cmake-build-debug* & *cmake-build-release*: katalogi budowania

## Użyte narzędzia

### Proces budowania

### Biblioteki zewnętrzne

## Architektura

Silnik składa się z siedmiu modułów. Moduły:

- generator kodu:  ...
- rdzeń: funkcje pomocnicze: ...
- zasoby: wczytywanie i zapisywanie danych sceny i konfiguracji globalnej
- scena: konstrukcja grafu sceny, drzewa sceny i listy renderującej
- potok graficzny: abstrakcja podstawowych operacji renderowane używających Vulkan
- przebieg renderowania: ...
- graf renderowania: ...

Każdemu modułowi zostanie poświęcony osobny podrozdział.

## Generator kodu

...

## Rdzeń

...

## Dane

[???]
...

## Zasoby

Moduł zasobów jest odpowiedzialny za zapisywanie i wczytywania sceny z bazy zasobów. ...

### Definicje

W kontekście silnika zasób (ang. *asset*) można zdefiniować jako ogół jego elementów, które nie są częścią jego kodu
źródłowego i mogą być niezależnie od niego dodawane, usuwane i modyfikowane.

Zasoby można podzielić na zasoby wejściowe (surowe) i wyjściowe (przetworzone).

Zasoby wejściowe mają formę plików w formacie przystosowanym do edycji przy użyciu zewnętrznego oprogramowania.
Przykładem zasobu wejściowego jest model 3D stworzony w programie do grafiki 3D Blender [BLENDER].

[OBRAZEK: MODEL 3D]

Zasoby wyjściowe mają formę plików w formacie przystosowanym do manipulacji przez silnik. Przykładami zasobów
wyjściowych są pliki z rozszerzeniami *.uasset* i *.umap* używane przez silnik Unreal Engine do przechowywania zasobów w
zoptymalizowanym formacie binarnym.

Potok zasobów (ang. *asset pipeline*) to część silnika odpowiadająca za konwersję zasobów wejściowych na zasoby
wyjściowe. Konwersja ta jest spowodowana wyżej opisanymi różnymi wymaganiami dotyczącymi ich formatów.

Poniższy diagram przedstawia przepływ pracy zasobów:

```mermaid
graph TD;
    CGI[Zewnętrzne oprogramowanie] --> SA
    SA[Zasób wejściowy] --> AP
    AP[Potok zasobów] --> RF
    RF[Zasób wyjściowy] --> R
    R[Plik wykonywalny]
```

Baza zasobów (ang. *asset database*) to zasób wyjściowy mający na celu zgromadzenie informacji o wszystkich zasobach
używanych przez silnik. ...

### Implementacja

Rodzaje zasobów wejściowych wyróżniownych na potrzeby projektu:

- ...

Rodzaje zasobów wyjściowych wyróżniownych na potrzeby projektu:

- ...

Na potrzeby projektu wyróżniono następujące rodzaje zasobów:

- konfiguracja globalna,
- shadery,
- kamera,
- światło
- ...

Wymienione powyżej rodzaje zasobów są opisane w następnych podrozdziałach.

*Konfiguracja globalna* Plik ... ...

## Scena

Moduł sceny jest odpowiedzialny za wygenerowanie ze sceny listy obiektów renderowania. Struktury:
Scene data... Scene graph... Scene tree... Render cache... Render cache list...

...

## Potok graficzny

Moduł potoku graficznego udostępnia zbiór obiektów pozwalających na użycie bilioteki graficznej Vulkan za pośrednictwem
wygodniejszej dla programisty abstrakcji. ...

## Przebieg renderowania

Moduł przebiegu renderowania jest odpowiedzialny za wyrenderowanie całości bądź części listy renderującej. Przebieg
renderowania nagrywa polecenia do podanego bufora poleceń.
[DIAGRAM]

...

## Graf renderowania

Moduł grafu renderowania jest odpowiedzialny za stworzenie przebiegów renderowania na podstawie wysokopoziomowego
deklaratywne opisu renderowania dostarczonego przez programistę. ...

# 4. Badania

...

# 5. Podsumowanie

...

# Bibliografia

...
[PEP] https://peps.python.org/pep-0405/
[BLENDER] https://www.blender.org/
[GLTF] https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html
[GLTF_LIGHT] https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md
[SRAA] Subpixel Reconstruction Antialiasing for Deferred Shading

# TODO

/vulkan/debug.h Obiekt vulkan_debug pozwala na dodawanie informacji debugujących do obiektów Vulkan. Jest to osiągnętę
przy pomocy rozszerzenia VK_EXT_debug_utils. Rozszerzenie VK_EXT_debug_utils pozwala na stworzenie komunikatora
debugowania (ang. debug messanger) przechwytującego wszystkie komunikaty debugowania wygenerowane przez moduł ładowania,
warstwy i sterownik Vulkan. Przechwycone komunikaty debugowania są przekazywne do wywołania zwrotnego, które loguje
wiadomość z odpowiednim priotytetem. Użycie debuggera wspierającego warunkowe punkty przerwania (ang. conditional
breakpoint) dla wiadomości o priorytecie error lub fatal pozwala na zatrzymanie działania programu tuż po zgłoszeniu
błędu przez warstwy walidacji, co upraszcza proces debugownia.
[OBRAZEK]

Rozszerzenie VK_EXT_debug_utils pozwala na dodawanie nazw do obiektów Vulkan oraz etykiet do regionów kolejek i buforów
poleceń. Nazwy i etykiety są używane w wiadomościach debugujących i pokazywane przez zewnętrzne narzędzia do debugowania
grafiki, co upraszcza proces debugowania.
[OBRAZER RENDERDOC]

-------------
/vulkan/constants.h Lista stałych wartości uznanych za zbyt niepraktyczne aby pozwolić na ich modyfikację przy użyciu
konfiguracji globalnej:

Stała FRAMES_IN_FLIGHT określa liczbę ramek, do których mogą być jednocześnie renderowane przez GPU. Domyślna wartość to
2, co pozwala na podwójne buforowanie. Stała MAX_OFFSCREEN_TEXTURE_COUNT określa maksymalną liczbę obrazów
pozaekranowych. Domyślna wartość to 16. Stała MAX_RENDER_TARGET_COUNT określa maksymalną liczbę celów renderowania,
które mogą być używane podczas jednego przebiegu renderowania. Domyślnie 8. Stała MAX_INDIRECT_DRAW_COMMAND_COUNT.
Domyślnie 1024. Stała MAX_MATERIAL_COUNT Domyślnie 128. Stała MAX_DIRECTIONAL_LIGHT_COUNT określa maksymalną liczbę
świateł kierunkowych. Domyślnie 1. Stała MAX_POINT_LIGHT_COUNT określa maksymalną liczbę świateł punktowych. Domyślnie
128 Stała MAX_TEXT_CHARACTER_COUNT określa maksymalną liczbę znaków w renderowanym ciągu znaków. Domyślnie 256. Stała
MIN_DELTA_TIME określa minimalny czas pomiędzy wywołanami funkcji update podanej przez użytkownika. Domyślnie (1.0 /
60.0) (60 ramek na sekundę). Stała WORLD_UP określa wektor interpretowany jako "w górę" w przestrzeni świata. Domyślna
wartość to (0, 1, 0). Stałe mogą być używane przez shadery - ich definicje preprocesora są umieszczane na początku kodu
źródłowego w języku GLSL przed kompilacją.
-------------
/vulkan/common.h Globalna tablica typów obrazów wspieranych przez silnik:
[TABELA]
Struktura aabb reprezentuje prostokąt ograniczający (ang. axis-aligned bounding box, AABB). Pozwala na obliczenie
najmniejszej i największej pozycji renderowanych wierzchołków sceny, co pozwala na obliczenie domyślnej pozycji kamery w
taki sposób, żeby obejmowała ona całą scenę. Funkcja get_perspective_matrix oblicza macierz rzutu perspektywicznego z
przestrzeni widoku do przestrzeni przycinania (ang. clip space).
[OBRAZEK]

Funkcja get_orthographic_matrix oblicza macierz rzutu prostokątnego z przestrzeni widoku do przestrzeni przycinania (
ang. clip space). Przestrzeń przycinania w Vulkanie jest prawoskrętna z flipped Y.
-------------
/src/assets Zawiera obiekty zasobów. Obiekt zasobów reprezentuje zasoby znajdujący się w bazie zasobów. Obiekty zasobów
są obiektami POD (ang. Plain Old Object), ich jedynym zadaniem jest udostępnienie informacji o zasobach elementom
silnika na wyższym poziomie.
[DIAGRAM]
Struktura obiektów zasobów jest inspirowana strukturą zasobów w formacie glTF pokazaną na poniższym diagramie:
[DIAGRAM https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#concepts-general]
W formacie glTF scena składa się z węzłów, które są obiektami przeznaczonymi do wyrenderowania. Węzeł zawierać lokalną
transformację przestrzeni oraz referencję od renderowanych zasobów.
------
/src/assets/common.h Definiuje interfejs współdzielony przez obiekty zasobów. Współdzielone pola:

- klucz zasobu: otrzymany w wyniku użycia funkcji haszującej na polach obiektu jednoznacznie identyfikujących obiekt
  jako unikalny zasób, rodzaj optymalizacji
- wskaźnik do sceneData: każdy zasób zawiera wskaźnik do obiektu sceny któym jest zarządzany,
- wskaźniki prev i next (intrusive doublylinked list). Współdzielone funkcje:
- init: inicjalizacja
- deinit: deinicjalizacja
- calculate_key: oblicza klucz zasobu, wymagane ponowne obliczenie po każdej modyfikacji obiektu,
- serialize: serializacja, zapis pól obiektu do bazy zasobów
- deserialize: deserializacja, odczyt pól obiektu z bazy zasobów, używa klucza
- debug_print: funkcja pomocnicza używana podczas debugowania, loguje pola obieku

------
/src/assets/camera.h Zasób reprezentujący parametry kamery. Dostępne są dwa rodzaje kamery:

- ortograficzna,
- perspektywiczna. Kamera perspektywiczna posiada parametry:
- fovY: vertical field of view (radians)
- aspectRatio:
  Kamera or
- magX: Horizontal magnifiaction of view
- magY: vertical magnification of view
- nearZ:
- farZ:
  Pola nearZ i farZ definiują kolejno odległości bliskiej i dalekiej przestrzeni przycinania. Ostateczna pozycja i
  rotacja kamery jest wyliczana na podstawie wynikowej transformacji przestrzeni obiektu, który posiada parametry
  kamery.

------
/src/assets/light.h Zasób światła. Reprezentuje światło punktowe na scenie. Struktura zasobu jest inspirowana
rozszerzeniem KHR_lights_punctual formatu glTF 2.0. Dostępne są dwa rodzajów światła punktowego:

- światło kierunkowe (ang. directional light)
- światło punktowe (ang. point light)
  [DIAGRAM]
  Wszystkie rodzaje świateł posiadają parametry:
- intensywność,
- kolor. Światło kierunkowe definiuje dodatkowy parametr kierunek w przestrzeni świata. Światło punktowe i reflektorowe
  definiuje dodatkowy parametry:
- pozycja: punkt w przestrzeni świata.
- zakres: promień sfery zdefiniowanej w pozycji światła. poza którą intensywność światła osiąga zero.

------
/src/assets/material.h Zasób materiału. Reprezentuje parametry materiału używanego podczas renderowania powierzchni
prymitywów.

Materiał jest zdefiniowany przy użyciu metallic-roughness material model posiada następujące właściwości:

- kolor podstawowy (ang. base color): informacja o kolorze obiektu
- metaliczności (ang. metalness): określa metaliczność materiału, tj. czy materiał jest metalem czy dielektrykiem
- chropowatość (ang. roughness): określa chropowatość materiału, tj. czy materiał jest błyszczący czy matowy

Materiał definiuje kolor podstawowy (ang. base color) przy użyciu parametrów:

- współczynnik koloru podstawowego: vec4
- tekstura koloru podstawowego: komponent RGB

Materiał definiuje metaliczność i chropowatość przy użyciu parametrów:

- współczynnik metaliczności: liczba zmiennoprzecinkowa w zakresie <0:1>, czy materiał jest metalem czy dielektrykiem
- współczynnik chropowatości: liczba zmiennoprzecinkowa w zakresie <0:1>, określa czy materiał jest błyszczący czy
  matowy
- tekstura metaliczności-chropowatości: opcjonalne, wartość metalicznści są w kanale B tekstury. wartość metalicznści są
  w kanale G tekstury

Materiał może dodatkowo definiować mapę normalnych (ang. normal map) jest używana do techniki mapowania normalnych.

------
/src/assets/mesh.h Zasób siatki. Reprezentuje grupę prymitywów graficznych. Siatka jest uzyskiwana z modelu
przygotowanego w programie do modelowania 3D. Siatka jest tożsama z geometrią obiektu na scenie. Podział na siatkę i
prymitywy ma na celu zmniejszenie redundancji - przykładowo siatka modelu auta może zawiarać 4 prymitywy koła.
[OBRAZEK]
/src/assets/vertex_attribute.h Zasób atrybutu wierzchołka. Wierzchołek składa się z kilku różnych atrybutów wierzchola,
np. pozycji, normalnej, i koloru. Ten zasób reprezentuje dane atrybutu wierzchołka w postaci tablicy elementów.
Wyróżniowo cztery rodzaje elementów:

- uint32_t:
- vec2,
- vec3,
- vec4.

------
/src/assets/primitive.h Zasób primitywu graficznego. Reprezentuje część siatku obiektu. Primityw składa się z dwóch
elementów: geometrii oraz materiału. Jeden prymityw zawiera wszystkie dane wymagane do wygenerowania jednego polecenia
rysowania. Geometria prymitywu składa się z:

- rodzaju topologii,
- indeksów wierzchołków,
- atrybutów wierzchołków. Topologia definiuje sposób renderowania wierzchołków.
  [DIAGRAM]
  Na potrzeby silnika wyróżniono pięć rodzajów atrybutów wierzchołków:
- pozycja: vec3
- normalna: vec3
- kolor: vec3
- koordynat tekstury: vec2
- styczna: vec4 Wierzchołek jest sumą atrybutów wierzchołków.
  [DIAGRAM]
  Indeksy wierzchołków pozwalają na kompresję bufora wierzchołków poprzez wprowadzenie bufora indeksów.
  [DIAGRAM]

------
/src/assets/object.h Zasób obiektu. Reprezentuje jeden element sceny. Zawiera referencje do:

- zasobu siatki,
- zasobu kamery,
- zasobów obiektu, Zawiera macierz 4x4 z lokalną transformacją przestrzeni. /src/assets/texture.h Zasób bitmapy.
  Reprezentuje obraz w postaci nieskompresowaną bitmapy. Bitmapa to prostokątna tablica pikseli. Rozmiar bitmapy jest
  specyfikowany przy użyciu szerokości, wysokości, głębokości oraz liczby ścian (domyślnie 1 ściana, 6 ścian dla
  tekstury sześciennych). Rozmiar piksela jest specyfikowany przy użyciu liczby kanałów - jeden kanał jest
  reprezentowany przez jeden bajt (8-bitowe kanały). Obecnie silnik nie wspiera ładowania tekstur zmiennoprzecinkowych (
  np. mapy sześcienne HDR), więc założenie 8-bitów per kanał jest wystarczające. Zasób samplera. Reprezentuje parametry
  samplera używany podczas próbkowania obrazu. VkFilter magFliter i minFilter. VkSamplerAddressMode addressModeU,
  addressModeV.

Zasób tekstury składa się z zasobu bitmapy i zasobu samplera. Wydzielono osobne zasoby dla zasobu skybox i zasobu
czcionki. Zasob skybox nazwę skyboxa i zasób tekstury. Zasób czcionki posiada nazwę czcionki, zasób tekstury, ciąg
znaków z alfabetem czcionki i rozmiar jednego glifu w pikselach.
-------------
/src/data Obiekty pozwalające na parsownie plików konfiguracyjnych i baz danych. Pierwszy moduł używający wygenerowanego
kodu.

------
/src/data/config.h Parsowanie konfiguracji w formacie INI.
------
/src/data/db.h Definiuje obiekt bazę danych SQLite. SQLite posiada "dynamiczny" system typowania (ang. dynamic type
system), który pozwala na słabe typowanie przy użyciu następujących typów proste: INT, TEXT, BLOB Biblioteka dodaje
dodatkowe typy złożone: VEC3,... oraz ich wersje tablicowe: VEC3_ARRAY, ... - baza danych SQLite wciąż używa typów
prostych, ale następuje serializacja i deserializacja typów złożonych.
[LISTING]
Biblioteka pozwala na przeprowadzanie standardowych operacji wyboru (ang. select) i wprowadzania (ang. insert).
[LISTING]
------
/src/data/asset_db.h Definiuje obiekt bazę zasobów. Używa on wewnętrznie obiekt bazy danych SQLite i dodaje operacje
wyboru i wprowadzania dla poszczególnych tabel i kolumn bazy zasobów:
[LISTING]

-------------
/src/codegen Kod źródłowy języka C generowany automatycznie przy użyciu skryptów w języku Python. Język C nie posiada
mechanizmów pozwalających na metaprogramowanie z wyjątkiem makr preprocessora, który może zaspokoić część potrzeb
programisty chcącego przykładowo rozszerzyć dostępne rodzaje pętli, ale nie pozwala na bardziej skomplikowane analizę i
przekształcenia kodu, co przekonało autora do dodania automatycznej generacji kodu do projektu. Generacja kodu jest
wykonywana przez skrypt codegen.py. Skrypt parsuje pliki nagłówkowe języka C znajdujący się w katalogu /src z
pominięciem katalogu /src/codegen, do którego skrypt zapisuje wygenerowane pliki nagłówkowe i pliki źródłowe.
Wygenerowane pliki nagłówkowe są dołączane w innych modułach silnika . Wygenerowane pliki źródłowe są argumentami
kompilatora. Skrypt jest uruchamiany przez CMake na początku procesu budowania przed rozpoczęciem kompilacji właściwego
kodu źródłowego biblioteki napisanego w języku C. Działanie skryptu jest parametryzowane przy użyciu pliku konfiguracji
generatora kodu znajdującej się w /scripts/config.txt. Ma ona format INI. Format INI jest podzielony na sekcje, które
zawierają pary klucz-wartość:
[PRZYKŁAD]
/src/codegen/descriptors.h Definicje struktur helper_element i funkcji glsl_add wygenerowanych na podstawie analizy
struktur helper_struct pliku nagłówkowego /src/objects/descriptor.h.

Stuktury helper_struct opisują wewnętrzną strukturę buforów uniform znajdujących się na GPU. Relacja ta została
przedstawiona na poniższym diagramie:
[helper_struct w C -> helper_element na GPU & kod GLSL]
Układ pamięci struktur zdefiniowanych w języku C nie są koniecznie kompatybilne układem pamięci wymaganymi przez GPU.
Fakt ten wymusza generacje struktur helper_element, w których użyto atrybutów alignas udostępnianych przez C11 do
wyrównania pól struktury w układzie pamięci *scalar*.

Układ pamięci definiuje wielkości i wyrównania pól w strukturze w pamięci. Układy pamięci wspierane przez GPU są
specyfikowane w shaderach przy użyciu jednego z następujących coraz nowszych standardów:

- std140,
- std430,
- scalar.

Każdy kolejny standard pozwala na ciaśniejsze upakowanie pól w buforze, co skutkuje mniejszym zużyciem pamięci GPU.

Funkcje glsl_add zwracają ciągi znaków z definicjami struktur buforów uniform w języku GLSL i są używane podczas
generacji shaderów, co zostanie opisane później w pracy podczas opisu potoku renderowania.

Dodanie nowej struktury buffora uniform sprowadza się do zdefniniowania nowej struktury w /src/objects/descriptor.h, co
pozwala na szybkie dodawania nowych parametrów podczas pisania shaderów.

------
/src/codegen/globals.h Globalny obiekt globals wygenerowane na podstawie konfiguracji generatora kodu. Obiekt zawiera
ścieżki do plików z konfiguracją globalną i bazą zasobów.
------
/src/codegen/macros.h Makra preprocesora wygenerowane na podstawie konfiguracji generatora kodu. Struktura
wygenerowanych makr pozwala na użycie ich w ramach techniki X-macro.
[PRZYKŁAD LISTING]
Wygenerowane makra są używane do implementacji:

- konfiguracji globalnej,
- konfiguracji zasobów,
- bazy zasobów. Makra opisują strukturę konfiguracji globalnej i zasobów:
- sekcje
- pary klucz-wartość i ich domyślne wartości. Makra opisują strukturę bazy zasobów:
- typy podstawowe bazy danych i ich odpowiedniki w języku C [PRZYKŁAD]
- tabele w bazie danych

------
/src/codegen/meta.h Funkcje pozwalające na konwersję wartości typu wyliczeniowego na ciąg znaków.
[PRZYKŁAD LISTING]
Na jeden typ wyliczeniowy przypada jedna funkcja. Te funkcje to przykład koncepcji w metaprogramowaniu zwanego
refleksją. Funkcje są użyteczne podczas debugowania - podczas działania programu typy wyliczeniowe języa C są zwykłymi
liczbami, człowiek lepiej orientuje się widząc ich nazwy.

-------------
/src/core/thirdparty.h Nagłówek thirdparty.h dołączający nagłówki bibliotek zewnętrznych. Nagłówek prekompilowany (ang.
precompiled header, PCH) z powodów wydajnościowych. Część bibliotek zewnętrznych ma formę jedynie nagłówków (ang.
header-only library). W tradycyjnych bibliotekach języka C kod jest podzielony na pliki nagłówkowe i pliki źródłowe.
Pliki nagłówowe zawierają deklaracje (funkcji, struktur, typów wyliczeniowych itp.) widocznych dla użytkownika końcowego
i powinny być dołączone do programu przy użyciu dyrektywy #include preprocesora. Pliki źródłowe zawierają definicje
deklaracji plika nagłówkowego i powinny być dołączone do programu używając argumentów kompilatora (jeśli dodawane są
niezbudowane pliki źródłowe) bądź linkera (jeśli dodawane są zbudowane pliki biblioteczne). W przypadku jedynie
nagłówków dostęp do definicj tradycyje znajdujących sę z plikach źródłowych jest uzyskiwany poprzez ponowne dołączenie
pliku nagłówkowego przy użyciu dyrektywy #include przy wcześniejszym zdefiniowaniu symbolu preprocesora. Nagłówek
thirdparty.h posiada odpowiadający mu plik źródłowy thirdparty.c robiący to.
------
/src/core/platform.h Wieloplatformowe funkcje. Funkcja panic(). Używa atrybutu noreturn i pozwala na zamknięcie programu
po wystąpieniu fatalnego błędu. Odkrywanie ścieźki z katalogiem zawierającym plik wykonywalny - potrzebne do znalezienia
plików z konfiguracją i zasobami. Na systemie Linux używana jest funkcja readlink() do odczytania pliku /proc/self/exe
oraz funkcja dirname(). Na systemie Windows używana jest funkcja GetModuleFileName() oraz funkcja PathRemoveFileSpec().
Obsługa plików - zapisywanie i wczytywanie. Inicjalizacja systemu logowania.

------
/src/core/log.h System logowania wiadomości. Logowanie znacząco upraszcza proces debuggowania. Logowanie odbywa się
poprzez funkcje zachowujące się tak samo jak funkcja printf - pierwszy argument to ciąg znaków z znakami formatującymi,
reszta argumentów to formatowane wartości. Rozróżniane jest pięć priorytetów wiadomości:

- debug,
- info,
- warn,
- error,
- fatal. Wiadomości są zapisywane do standardowego wyjścia (stdou albo stderr) oraz do pliku na dysku.

------
/src/core/junk.h Proste funkcje i makra które mogą być potencjalnie używane na wskroś wszystkich modułów w całej
bibliotece. Symbole preprocessora definiowane warunkowo z zależności od systemu operacyjnego dla którego biblioteka jest
kompilowana (Linux, MacOS, Windows). Przetwarzanie ciągów znaków. Liczenie bitów w flagach. Używanie funkcji skrótów.
Makra upraszczające użycie preprocesora języka C. Makra upraszczające opreracje na kontenerach. Zebranie wszystkich
drobnych funkcji pomocniczch w jedno miejsce projektu upraszcza proces implementacji.
------
/src/core/alloc.h

Funkcje pomocnicze wspomagające zarządzanie pamięcią:

- alokacja i deaokacja bloków pamięci na stercie,
- duplikacja bloków pamięci,
- porównywanie bloków pamięci.

Potrzebne, ponieważ działanie odpowiednich funkcji oferowane przez bibliotekę standardową języka C, chociaż oferują
żądaną funkcjonalność, opiera się na mechanizmie niezdefiniowanych zachowań (ang. undefined behaviour) dla niektórych
argumentów (wskaźnik NULL, rozmiar 0) i zachowań OOM (ang. Out-of-memory).

Funkcje pomocnicze są wrapperami na funccje biblioteki standardowej języka C z dodatkowymi instrukcjami warunkowymi
sprawdzającymi, czy wywołanie funkcji nie skutkuje niezdefiniowanym zachowaniem.

-------------
Vulkan wyróżnia dwa rodzaje zasobów: bufory i obrazy.

Bufor to ciągły blok pamięci który może być odczytany i zapisywany przez GPU. Bufor jest najprostszym i najbardzoei
podstawowym zasobem oferowanym przez Vulkan.

Obraz podobnie jak bufor reprezentuje ciągły blok pamięci, ale jego struktura jest bardziej skomplikowana i
interpretowana według od parametrów określonych podczas tworzenia obrazu.
Vulkan [... 2d/3d, mipmap (lod), array layers, tiling]
[OBRAZEK]
Oba rodzaje zasobów muszą posiadać dowiązaną alokację pamięci.

Użycie flag dobrze dopasowanych do użycia określonego przez rodzaj bufora jest wskazówką dla sterownika graficznego,
którą może on użyć do bardziej optymalnego wewnętrzne zarządzanie stanem i pamięcią GPU.
[LISTING alloc, create, bind buffer/image]

---
/objects/image.h
[OBRAZEK struktura]
Silnik wspiera osiem rodzajów obrazów:

- swap_chain
- material_base_color, mapowanie tekstur
- material_parameters
- normal_map
- cubemap
- font_bitmap
- offscreen_f16
- offscreen_depth_buffer
- offscreen_r8
  [...obrazy offscreen]
  [TABELA internal]

Obraz składa się z trzech obiektów Vulkan: obraz VkImage, alokacja pamięci VkDeviceMemory i widok obrazu VkImageView.
Vulkan nie pozwala na bezpośrednie używanie VkImage i wymaga utworzenia VkImageView. Stworzenie nowego obrazu wymaga
podania rządanego rodzaju oraz szerokości, wysokości i liczby kanałów. Vulkan pozwala na bezpośrednią specyfikację
kafelkowania obrazu (ang, image tiling). Vulkan wspiera kafelkowanie liniowe, w którym teksele obrazu są szeregowane w
pamięci wierszami (ang. row-major order) podobnie jak w tablicach dwuwymiarowych w języku C. Vulkan wspiera też
kafelkowanie optymalne, w którym teksele obrazu są umieszczone w pamięci w sposób zdefiniowany przez sterownik graficzny
mający na celu bardziej wydajny dostęp do pamięci.
[OBRAZEK tiling]
Silnik używa wyłącznie kafelkowania optymalnego, które jest wydajniejsze od kafelkowania liniowego i jest w czasie
pisania pracy według portalu GPUInfo.org szerzej wspierane. Silnik nie wspiera MSAA - współpraca MSAA z renderowaniem
odroczonym jest możliwa [SRAA], ale wprowadzany przez nie poziom kompilacji implementacji renderowania odroczonego
został uznany za zbyt duży, i dlatego jest poza zakresem tej pracy. Z tego powodu wszystkie obrazy, w tym te służące
jako cele renderowania, , CPU nie używa obrazów używanych przez GPU do renderowania, dlatego też pamięć wszystkich
rodzajów obrazów jest pamięcią DEVICE_LOCAL, co powinno skutkować najszybszym dostępem do obrazów przez GPU. Kopiowanie
danych z CPU do GPU jest ważną operacją pozwalającą na wstępne wypełnienie obrazów danymi załadowanymi z bazy zasobów.
[LISTING]
W przypadku obrazów używanych do mapowania tekstur po skopiowaniu danych do mipmapy poziomu 0 silnik generuje resztę
poziomów mipmap używając serii funkcji vkCmdBlitImage. Użycie tej funkcji wymaga obrazu w formacie wspierającym
filtrowanie liniowe. Dodatkowo ta funkcja może być wykonywana używając tylko kolejki graficznej, dlatego też bufory
poleceń one-shot nie mogą być wykonywane używając tylko kolejki transferowej, mimo możliwej większej wydajności.
[LISTING mipmap]
Format obrazu jest wybierany przy pomocy algorytmu opisanego w poniższym listingu. Algorytm generuje listę formatów
spełniających wymagania specyfikowane przez rodzaj obrazu i liczbą kanałów równą lub większą od liczby kanałów używanej
przez obraz. Ostateczny format to ten z z najmniejszą liczbą kanałów wciąż wspierany przez sterownik graficzny.
[LISTING find_image_format]

----
/objects/buffer.h
[OBRAZEK struktura]
Silnik wyróżnia cztery rodzaje buforów:

- bufor wierzchołków,
- bufor indeksów,
- bufor poleceń rysowania pośredniego,
- bufor uniform.

Bufory wierzchołków, indeksów i poleceń rysowania pośredniego są źródłem danych odczytywanych przez stałe funkcji potoku
graficznego. Bufory uniform są źródłem danych odczytywanych przez shadery. Bufor składa się z dwóch obiektów Vulkan:
VkBuffer i VkDeviceMemory. Rodzaj bufora przekłada się na flagi stosowane podczas tworzenia obiektów Vulkan, co zostało
podsumowane w poniższej tabeli:
rodzaj bufora / flagi użycia bufora (VkBufferUsageFlags) / flagi właściwości pamięci (VkMemoryPropertyFlags)
bufor wierzchołków / TRANSFER_DST | VERTEX_BUFFER / DEVICE_LOCAL bufor indeksów / TRANSFER_DST | INDEX_BUFFER /
DEVICE_LOCAL bufor poleceń rysowania pośredniego / TRANSFER_DST | INDIRECT_BUFFER / HOST_VISIBLE | HOST_COHERENT bufor
uniform / UNIFORM_BUFFER / HOST_VISIBLE | HOST_COHERENT

Kopiowanie danych z CPU do bufora w GPU jest ważną operacją wykonywaną na początku każdej ramki mającą na celu
wypełnienie pamięci GPU danymi używanymi przez polecenia renderowania. Może się ono odbyć na dwa sposoby w zależności od
użytych flag właściwości pamięci. Dla pamięci HOST_VISIBLE silnik używa funkcji vkMapMemory() do uzyskania wskaźnika do
regionu pamięci i bezpośredniego skopiowania pamięci przy użyciu CPU.
[LISTING vkMapMemory]
Dla innych rodzajów pamięci, które nie mogą być bezpośrednio zapisywane przez CPU (w tym DEVICE_LOCAL) silnik używa
bufora tymczasowego i funkcji vkCmdCopyBuffer() w bufore poleceń one-shot.
[LISTING staging]

---

## objects/descriptor.h

### Vulkan

### Silnik

Silnik zgodnie z duchem renderowania bez dowiązań dąży do zmniejszenia liczby alokowanych deskryptorów i eliminacji
dowiązywanie zasobów między poleceniami rysowania.

Tworzona jest jedna pula deskryptorów, która pozwala ona na alokację jednego globalnego zbioru deskryptorów przy pomocy
jednego układu zbioru deskryptorów. Cykl życia tych obiektów jest taki sam - są one stworzone i zniszczone wraz z resztą
stanu renderowania.

Maksymalna liczba deskryptorów buforów zależy od liczby struktur uniform_buffer_struct wykrytych podczas automatycznej
generacji kodu. Maksymalna liczba deskryptorów próbkowanych obrazów zależy od limitu
maxPerStageBindlessDescriptorSampledImages.

Zbiór deskryptorów jest dowiązywany tylko raz wraz z resztą stanu renderowania.

Sposób zarządzania deskryptorami w silniku został przestawiony na poniższym diagramie:
[...set in engine]

## objects/input.h

Dane wejściowe myszy i klawiatury są obsługiwane całkowicie przy pomocy GLFW.

GLFW pozwala na stosowania wirtualnej pozycji kursora. Kursor myszy jest ukryty i jego fizyczna pozycja w oknie jest
centrowana co klatkę - program ma dostęp do wirtualnej pozycji, co pozwala na nieograniczony ruch myszy.

Wirtualna pozycja kursowa jest używana do implemenacji sterowania kamerą.

## Obiekty

Obiekty oferują parę metod create() i destroy(). Alokują i dealokują one pamięć dla instancję obiektu oraz inicjalizują
i niszczą ją. Analogiczna para metod init() i deinit() inicjalizują i niszczą instancję obiektu bez alokacji i
dealokacji jej pamięci. Obiekty oferują metodę debug_print() logującą informacje użyteczne podczas debugowania.

## objects/textures.h

### Obiekt textures

Obiekt textures zarządza wszystkimi teksturami i materiałami. Metoda update() jest funkcją no-op. Metoda
send_to_device() wysyła obrazy tekstur do GPU. Metody add_texture() i add_material() tworzą nowe tekstury i materiały.
Są one niszczone wraz z instancją obiektu. Funkcja glsl_add_textures() dodaje kwalifikatory układu do kodu GLSL shadera
pozwalające na dostęp do tekstur.

### Tekstura

Tekstura to obraz, który może być próbkowany przez shadery.

W silniku tekstura składa się z następujących elementów:

- zasób tekstury,
- obraz,
- próbnik,
- identyfikator tekstury.

### Tworzenie tekstury

Tekstura jest tworzona przy pomocy metdy add_texture(), której wejściem jest zasób tekstury.

Stworzone tekstury są przechowywane w tablicy mieszającej w strukturze vulkan_textures, której kluczem jest zasób
tekstury. Pozwala to na uniknięcie duplikacji pamięci podczas tworzenia tekstur.

Obraz i próbnik są tworzone na podstawie danych zawartych w zasobie tekstury.

Identyfikator tekstury to 32-bitowa liczba całkowita. Pierwszy identyfikator to zero, każdy następny jest uzyskiwany
poprzez inkrementację. Maksymalna liczba stworzonych tekstur jest równa maksymalnej liczbie deskryptorów próbkowanych
obrazów.

### Dostęp do tekstur w shaderach

Dostęp do tekstur w shaderach odbywa się przy użyciu globalnej tablicy tekstur, która jest pojedyńczą tablicą
deskryptorów próbkowanych obrazów znajdującą się w ostatnim dowiązaniu globalnego zbioru deskryptorów.

Identyfikator tekstury jest indeksem w tej tablicy. Jest on używany do aktualizacji deskryptora obrazem i próbnikiem
tekstury.

Kwalifikatory układu w shaderach GLSL dla tablicy deskryptorów próbkowanych obrazów 2D są mają następującą formę:

```
layout(set = 0, binding = {numer ostatniego dowiązania}) uniform sampler2D textures2D[];
layout(set = 0, binding = {numer ostatniego dowiązania}) uniform samplerCube texturesCube[];
```

Powyższy kod definiuje dwie zmienne shadera, które posiadają identyczne numery zbioru i dowiązania deskryptorów oraz
różne typy zmiennych shadera.

Ta sytuacja jest dozwolona przez specyfikację Vulkana (sekcja **5.6.3. DescriptorSet and Binding Assignment**) z
zastrzeżeniem, że shader może używać jedynie tych zmiennych shadera, których typ odpowiada rodzajowi dowiązanego
deskryptora. Przykładowo, jeśli indeks *i* w tablicy deskryptorów tekstur opisuje teksturę 2D, to dostęp do niej w
shaderze musi się odbywać przy użyciu wyrażenia *textures2D[i]* - użycie wyrażenia *texturesCube[i]* jest
niezdefiniowanym zachowaniem.

Technika ta eliminuje potrzebę tworzenia i zarządzania osobnymi dowiązaniami deskryptorów dla różnych rodzajów tekstur i
pozwala na unifikację próbkowania tekstur - dostęp do tekstury wymaga jedynie wiedzy o jego identyfikatorze *i* i
rodzaju:

```
vec4 tex2DSample = texture(textures2D[i], vec2(0));
vec4 texCubeSample = texture(texturesCube[], vec3(0));
```

### Materiał

Materiał to zbiór parameterów i tekstur używanych do przez shadery do renderowania powierzchni prymitywów.

W silniku materiał składa się z następujących elementów:

- zasób materiału,
- tekstury materiału:
    - tekstura koloru podstawowego,
    - tekstura metaliczności-chropowatości,
    - teksura normalnych,
- identyfikator materiału.

### Tworzenie materiału

Materiał jest tworzony przy pomocy metody add_material(), której wejściem jest zasób materiału.

Stworzone materiały, podobnie jak tekstury, są przechowywane w tablicy mieszającej w strukturze vulkan_textures, której
kluczem jest zasób materiału.

Tekstury materiału są tworzone na podstawie danych zawartych w zasobie materiału. Zasób materiału jest także używany do
przechowywania parametrów materiału.

Identyfikator materiału jest 32-bitową liczbą całkowitą. Pierwszy identyfikator to zero, każdy następny jest uzyskiwany
poprzez inkrementację. Maksymalna liczba stworzonych materiałów jest równa stałej MAX_MATERIAL_COUNT.

### Dostęp do materiałów w shaderach

Dostęp do materiałów w shaderach odbywa się przy użyciu części globalnej ujednoliconego bufora uniform. Zawiera on
tablicę struktur *material_helper_element*, w której identyfikator materiału pozwala na dostęp do jego parametrów i
identyfikatorów tekstur:

```
struct material_helper_element {
  uint baseColorTextureId;
  vec4 baseColorFactor;
  uint metallicRoughnessTextureId;
  uint normalMapTextureId;
  float metallicFactor;
  float roughnessFactor;
};
...
material_helper_element materials [MAX_MATERIAL_COUNT];
...
vec4 baseColorFactor = global[globalIdx].materials[materialId].baseColorFactor;
uint baseColorTextureId = global[globalIdx].materials[materialId].baseColorTextureId;
vec4 baseColorSample = texture(textures2D[baseColorTextureId], inTexCoord);
```

## objects/shader.h

### Obiekt shader

Obiekt shader reprezentuje pojedyńczy shader i jest odpowiedzialny za kompilację ich do formy używanej przez Vulkan.

### Shader

Shader to program specyfikujący operacje wykonywane podczas etapu potoku graficznego dla każdego elementu przetwarzanego
przez ten etapu potoku (np. wierzchołka albo fragmentu).

W silniku shader składa się z następujących elementów:

- typ shadera
- kod źródłowy GLSL,
- kod bajtowy SPIR-V,
- moduł shadera Vulkan,
- refleksja shadera.

Typ shadera zależy od tego, dla którego etapu potoku graficznego jest on przeznaczony. Silnik wspiera dwa typy shaderów:

- shader wierzchołków,
- shader fragmentów.

Kod źródłowy GLSL reprezentuje shader w formie tekstowej przy użyciu języka programowania potoku graficznego składniowo
zbliżonego do jezyka C. Jest on uzyskiwany poprzez użycie obiektu *shader_generator*.

Kod bajtowy SPIR-V reprezentuje shader w formie ustandaryzowanej binarnej reprezentacji pośredniej. Jest on uzyskiwany
poprzez kompilację kodu źródłowego GLSL biblioteką zewnętrzną *shaderc*.

```
shaderc_compiler_t compiler = shaderc_compiler_initialize();

shaderc_compile_options_t options = shaderc_compile_options_initialize();
shaderc_compile_options_set_target_env(options, shaderc_target_env_vulkan, 0);

const char *glslCode = ...;
size_t glslLen = strlen(glslCode);
shaderc_shader_kind shaderType = ...;
const char *inputFileName = "shader";
const char *entryPointName = "main";
shaderc_compilation_result_t result = shaderc_compile_into_spv(
    compiler, glslCode, glslLen,
    shaderType, inputFileName, entryPointName, NULL);
shaderc_compile_options_release(options);

if (shaderc_result_get_num_errors(result)) {
    const char *errorMsg = shaderc_result_get_error_message(result);
    panic("compilation error: %s\n", errorMsg);
}

size_t spvSize = shaderc_result_get_length(result);
uint32_t *spvCode = (uint32_t *)malloc(spvSize);
core_memcpy(spvCode, (uint32_t *)shaderc_result_get_bytes(result), spvSize);

shaderc_result_release(result);
shaderc_compiler_release(compiler)
```

Moduł shadera Vulkan reprezentuje shader w formie, która może być używana bezpośrednio przez potok graficzny Vulkan.
Jest on uzyskiwany poprzez kompilację kodu bajtowego SPIR-V funkcją vkCreateShaderModule().

Obiekt shader_reflect reprezentuje mechanizm refleksji shadera. Pozwala on na badanie struktury skompilowanego shadera.
Operuje on na kodzie bajtowym SPIR-V. Jest on używany podczas testów oraz do logowania informacji debugujących.

## objects/swap_chain.h

### Obiekt swap_chain

Obiekt swap_chain reprezentuje łańcuch wymiany. Metoda get_aspect_ratio() zwraca proporcje łańcucha wymiany (wysokość do
szerokości).

### Łancuch wymiany

TODO implementacja

### Łańcuch wymiany w silniku

W silniku łańcuch wymiany składa się z następujących elementów:

- obiekt VkSwapchainKHR,
- uchwyty do prezentowalnych obrazy,
- widoki obrazów.

Obiekt VkSwapchainKHR jest obiektem Vulkan reprezentującym łańcuch wymiany. Jest on oferowany przez rozszerzenie
VK_KHR_swapchain będące częścią WSI. Stworzenie go wymaga wcześniejszego ustalenia wartości następujących parametrów:

- tryb prezentacji,
- format i przestrzeń kolorów prezentowalnych obrazów,
- rozmiar obrazów,
- liczba obrazów.

Wartości użytych parametrów muszą być wśród wartości wspieranych przez powierzchnię, które mogą być sprawdzone przy
pomocy następujacych funkcji:

- vkGetPhysicalDeviceSurfacePresentModesKHR() dla dostępnych trybów prezentacji,
- vkGetPhysicalDeviceSurfaceFormatsKHR() dla dostępnych formatów obrazów,
- vkGetPhysicalDeviceSurfaceCapabilitiesKHR() dla możliwości powierzchni.

Preferowany tryb prezentacji to MAILBOX. Jeśli jest niedostępny, to wybierany jest zawsze wspierany tryb prezentacji
FIFO.

Format definiuje rozmiar, strukturę i sposób kodowania podczas zapisu i dekodowania podczas próbkowania pojedyńczego
piksela obrazu. Przestrzeń kolorów definiuje metodę interpretacji pikseli obrazu przez silnik prezentacji podczas
prezentacji obrazu. Przestrzeń kolorów liniowa (niesprecyzowana) jest używana w shaderach. Przestrzeń kolorów SRGB jest
przeznaczona do wyświetlania na monitorach i jest powszechnia używana w obrazach.

Preferowany format i przestrzeń kolorów to B8G8R8A8_SRGB i SRGB. Jeśli nie są dostępne, to wybierane są pierwsze
dostępne.

Formaty z rodziny BGRA i przestrzeń kolorów SRGB powierzchni okna są zawsze wspierane na systemie Windows i w czasie
pisania pracy według portalu GPUInfo.org są one wspierane w ponad 96% systemów Linux.

Obliczenia modelu oświetlenia będące wyjściem shaderów fragmentów odbywają się w liniowej przestrzeni kolorów. Użycie
formatu B8G8R8A8_SRGB zamiast B8G8R8A8_UNORM pozwala na ominięcie ręcznej konwersji z przestrzeni liniowej do SRGB
podczas renderowania bezpośrednio do prezentowalnej tekstury - konwersja zostanie przeprowadzona przez sterownik
graficzny.

Rozmiar obrazów jest równy rozmiarowi powierzchni okna.




Mimo, że program posiada uchwyty obrazów, to wciąż są one zarządzane przez silnik prezentacji i przed użyciem muszą być
udostępnione programowi przy użyciu funkcji vkAcquireNextImageKHR() zwracającej indesk w wcześniej przygotowanej tablicy
uchwytów.

#### Użycie łańcucha wymiany



## objects/device.h

### Obiekt device

Obiekt device reprezentuje urządzenie. Jest on podstawowym obiektem przygotowującym podstawowe funkcjonalności używane
przez inne obiekty systemu renderowania. ...

W silniku obiekt device oferuje następujące funkcjonalności:

- obsługa okna,
- inicjalizacja Vulkan,
- wykonywanie poleceń one-shot,

#### Obsługa okna

Okno jest tworzone przy użyciu GLFW i jest reprezentowane obiektem *GLFWwindow*.

Przykładowy kod używający GLFW do stworzenia okna:

```
// Inicjalizacja biblioteki GLFW.
assert(glfwInit() == GLFW_TRUE);
assert(glfwVulkanSupported() == GLFW_TRUE);

// Stworzenie okna.
glfwDefaultWindowHints();
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
GLFWwindow *window = glfwCreateWindow(640, 480, "Window caption", NULL, NULL);

// Rejestracja funkcji wywołania zwrotnego.
glfwSetWindowUserPointer(window, callbackData);
glfwSetFramebufferSizeCallback(window, framebuffer_resize_callback);
glfwSetKeyCallback(window, key_callback);
glfwSetCursorPosCallback(window, mouse_callback);

// Wirtualny kursor myszy.
glfwSetInputMode(vkd->window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
```

Zarejestrowane funkcje wywołania zwrotnego są używane do wykrywania zmiany rozmiaru okna oraz przekazywania danych
wejściowych myszy i klawiatury do obiektu input.

#### Inicjalizacja Vulkan

TODO implementacja

###### Instancja

- podstawowe informacje o aplikacji: nazwa i wersja aplikacji oraz używanego silnika, najwyższa wersja Vulkan używana
  przez aplikację (1.2),
- włączone rozszerzenia instancji:
  - VK_KHR_get_physical_device_properties2,
  - dodatkowe rozszerzenia zwrócone przez funkcję glfwGetRequiredInstanceExtensions() używane do stworzenia powierzchni
    okna (VK_KHR_surface i dodatkowe rozszerzenie zależące od systemu)
  - w trybie debugowania VK_EXT_debug_utils używane przez obiekt debug.
- włączone warstwy: w trybie debugowania warstwa walidacji i jej używane funkcjonalności,
- komunikator debugowania dla instancji.

###### Powierzchnia

Powierzchnia jest tworzona przy użyciu funkcji glfwCreateWindowSurface().

###### Urządzenie fizyczne

Lista urządzeń fizycznych jest przefiltrowana do listy kandydatów przy użyciu następujących kryteriów wsparcia:

- wersja Vulkan: Vulkan 1.2,
- dostępne rodziny kolejek: graficzne i prezentacji,
- rozszerzenia urządzenia:
  - VK_KHR_swapchain,
  - VK_KHR_dynamic_rendering
  - VK_KHR_shader_non_semantic_info (w trybie debugowania, używane przez debugPrintf)
- wcześniej utworzonej powierzchni,
- funkcjonalności urządzenia fizycznego:
  - Vulkan 1.0 Core:
    - samplerAnisotropy: filtrowanie anizotropowego podczas próbkowania,
    - shaderUniformBufferArrayDynamicIndexing: jednolite dynamiczne indeksowanie tablic buforów uniform,
    - shaderSampledImageArrayDynamicIndexing: jednolite dynamiczne indeksowanie tablic próbkowanych obrazów,
    - multiDrawIndirect: polecenia wielokrotnego rysowania pośredniego,
    - drawIndirectFirstInstance: polecenia rysowania pośredniego z offsetem indeksu instancji
  - Vulkan 1.2 Core:
    - descriptorIndexing: indeksowanie deskryptorów,
    - shaderSampledImageArrayNonUniformIndexing: niejednolite dynamiczne indeksowanie tablic próbkowanych obrazów,
    - descriptorBindingVariableDescriptorCount: dowiązania deskryptora o zmiennej wielkości,
    - descriptorBindingPartiallyBound: częściowe dowiązanie deskryptorów,
    - runtimeDescriptorArray: tablice deskryptorów czasu wykonania,
    - scalarBlockLayout: układ pamięci *scalar*,
  - VK_KHR_dynamic_rendering:
    - dynamicRendering: dynamiczne przebiegi renderowania.

Każde urządzenie fizyczne listy kandydatów ma nadawany ranking poprzez oceniane jego typu od najlepszego do najgorszego:

- dyskretne GPU,
- zintegrowane GPU,
- wirtualne GPU (oferowane przez środowisko wirtualizacji),
- CPU (renderer programowy).

Urządzenie fizyczne z najwyższym rankingiem jest ostatecznie wybierane z listy kandydatów.

Po wybraniu urządzenia fizycznego zapamiętywane są następujące limity używane w
dalszych częściach silnika:

- obrazy i próbkowanie:
  - maxSamplerAnisotropy: maksymalny stopień filtrowania anizotropowego,
  - maxImageDimension2D: najwyższa obsługiwana wysokość lub szerokość obrazu 2D,
- aktualizacja deskryptorów:
  - maxUniformBufferRange: maksymalna wielkość bloku pamięci, którą można użyć do aktualizacji deskryptora bufora
    uniform,
  - minUniformBufferOffsetAlignment: minimalne wyrównanie offsetu bloku pamięci, które można użyć do aktualizacji
    deskryptora bufora uniform,
- tworzenie deskryptorów:
  - maxDescriptorSetUpdateAfterBindUniformBuffers: maksymalna liczba buforów uniform w układzie potoku,
  - maxDescriptorSetUpdateAfterBindSampledImages: maksymalna liczba próbkowanych obrazów w układzie potoku
  - maxPerStageUpdateAfterBindResources: maksymalna liczba zasobów które mogą być dostępne dla pojedyńczego etapu
    cieniowania w potoku graficznym,
- rysowanie pośrednie:
  - maxDrawIndirectCount: maksymalna liczba poleceń rysowania które mogą być wykonane przez jedno polecenie rysowania
    pośredniego.

###### Urządzenie logiczne

- kolejki: albo po jednej kolejce graficznej i prezentacji, albo jedna kolejka "uniwersalna" wspierająca obie rodziny
  poleceń,
- funkcje urządzenia fizycznego: te same jak te, których wsparcie było sprawdzane podczas wybierania urządzenia
  fizycznego,
- rozszerzenia urządzenia: jw.,
- warstwy walidacji.

###### Kolejki

Pobierane są po jednym uchwycie do koleki graficznej oraz kolejki prezentacji.

##### Wskaźniki funkcji rozszerzeń

```
  vkd->cmdBeginRendering =
      (PFN_vkCmdBeginRenderingKHR)vkGetInstanceProcAddr(vkd->instance, "vkCmdBeginRenderingKHR");
```

Pobieranie są wskaźniki do następujących funkcji rozszerzeń:

- VK_KHR_dynamic_rendering
  - vkCmdBeginRenderingKHR
  - vkCmdEndRenderingKHR
- VK_EXT_debug_utils
  - vkCmdBeginDebugUtilsLabelEXT
  - vkCmdEndDebugUtilsLabelEXT
  - vkCmdInsertDebugUtilsLabelEXT
  - vkSetDebugUtilsObjectNameEXT

#### Wykonywanie poleceń one-shot

Bufor poleceń one-shot jest przeznaczony do jednokrotnego transferu dużych ilości danych z bazy zasobów do pamięci
DEVICE_LOCAL na GPU i musi być użyty przez rozpoczęciem pętli głównej renderowania - pamięć, która może być modyfikowana
pomiędzy klatkami (np. bufory poleceń rysowania pośredniego) musi być pamięcią HOST_VISIBLE, która pozwala na mapowanie
pamięci i tymsamym pominęcie użycia buforów poleceń.

Bufor poleceń one-shot jest alokowany podczas tworzenia obiektu device z puli komend one-shot (VkCommandPool). Jest ona
przeznaczona do użycia z kolejką graficzną i stworzona z flagą TRANSIENT, która wskazuje sterownikowi graficznemu, że
zaalokowane bufory komend będą krótkotrwałe i zresetowane bądź zwolnione w stosunkowo krótkim czasie, co teoretycznie
pozwala sterownikowi na optymalizację metody alokacji pamięci.

Nagrywanie poleceń one-shot rozpoczyna się wywołaniem metody begin_one_shot_commands() rozpoczynającej nagrywanie bufora
poleceń funkcją vkBeginCommandBuffer() z flagą użycia ONE_TIME_SUBMIT wskazującą, że będzie on wykonany tylko jeden raz.

Nagrywanie jak kończone wywołaniem metody end_one_shot_commands(), która wykonuje następujące czynności:

```
1. Kończy nagrywanie bufora komend one-shot funkcją vkEndCommandBuffer(),
2. Wysyła bufor poleceń do kolejki graficznej funkcją vkQueueSubmit(),
3. Czeka na CPU aż kolejka zakończy wykonywanie poleceń na GPU funkcją vkQueueWaitIdle(),
4. Resetuje bufor komend one-shot poprzez reset całej puli komend one-shot funkcją vkResetCommandPool().
```

Synchronizacja między krokiem 2. i 4. zapobiega próbie zresetowania bufora poleceń wciąż używanego przez GPU.
Resetowanie puli poleceń automatycznie resetuje zaalokowane z niego bufory poleceń i jest uznawane za szybsze od
manualnego resetowania buforów poleceń przez warstwy walidacji:

```
Validation Performance Warning: [ UNASSIGNED-BestPractices-vkCreateCommandPool-command-buffer-reset ] Object 0: handle = 0x626000015100, type = VK_OBJECT_TYPE_DEVICE; | MessageID = 0x8728e724 | vkCreateCommandPool(): VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER is set. Consider resetting entire pool instead.
```

Bufor poleceń one-shot może być wypełniony dowolnymi poleceniami graficznymi Vulkan, ale silnik oferuje następujące
metody implementujące podstawowe operacje używane podczas transferu danych:

- one_shot_transition_image_layout(),
- one_shot_copy_buffer_to_buffer(),
- one_shot_copy_buffer_to_image(),
- one_shot_generate_mipmaps().

##### Metoda one_shot_transition_image_layout()

Metoda one_shot_transition_image_layout() zmienia układ całego obrazu - jego wszystkich warstw i poziomów mipmap. Używa
ona do tego metody device_transition_image_layout_command().

##### Układ obrazu

Obrazy są przechowywane w pamięci GPU w układach zdefiniowanych przez sterownik graficzny. Każdy układ ogranicza zbiór
możliwych operacji na obrazie w zamian za optymalizację dozwolonych operacji.

Układ obrazu nie jest tym samym co jego kafelkowanie - rodzaj używanego kafelkowania nie może być zmieniany po
utworzeniu obrazu, a układ obrazu jest zwykle często zmieniany podczas działania programu aby pozwolić GPU na
optymalizację sposobu użycia obrazu.

Przykładowe układy obrazu i dozwolone użycie:

- UNDEFINED: zawartość pamięci obrazu jest niezdefiniowana,
- GENERAL: wszystkie rodzaje dostępu,
- COLOR_ATTACHMENT_OPTIMAL: dołączenie koloru,
- DEPTH_STENCIL_ATTACHMENT_OPTIMAL:  dołączenie głębi/szablonu pozwalające na odczyt (testy głębi i szablonu) i zapis (
  wyjście głębi),
- DEPTH_STENCIL_READ_ONLY_OPTIMAL: dołączenie głębi/szablonu tylko do odczytu,
- SHADER_READ_ONLY_OPTIMAL: odczyt w shaderach jako próbkowany obraz,
- TRANSFER_SRC_OPTIMAL: obraz źródłowy w poleceniu transferu,
- TRANSFER_DST_OPTIMAL: obraz docelowy w poleceniu transferu,
- PRESENT_SRC_KHR: prezentowanie obrazu.

W przeciwieństwie do poprzednich API takich jak OpenGL, Vulkan nie zmienia automatycznie układu obrazu, co zmusza
programistę do samodzielnego śledzenia stanu układu obrazów i wykonywania przejść na poprawny układ przed użyciem ich
przez polecenia.

Graf renderowania jest odpowiedzialyn za śledzenie stanu układu obrazów na przestrzeni klatki i jest używany do
nagrywania barier pamięci obrazu gwarantujących odpowiednie przejścia układu obrazów.

##### Metoda device_transition_image_layout_command()

Metoda device_transition_image_layout_command() nagrywa barierę pamięci obrazu przeprowadzającą przejście ze *starego
układu obrazu* na *nowy układ obrazu*. Użycie bariery potoku wymaga zdefiniowania całej zależności pamięci, dlatego
każde przejście układu obrazów wymaga zdefiniowania jak dokładnie obraz będzie używany po przejściu i zakodowania tej
wiedzy używając źródłowych i docelowych etapów potoku oraz zakresów dostępów.

Poniższa tabela ilustruje logikę przejść używanych przez silnik:

| stary układ obrazu | nowy układ obrazu | uzycie obrazu po przejściu | źródłowy etap potoku | docelowy etap potoku | źródłowy zakres dostępu | docelowy zakres dostępu |
| --- | --- | --- | --- | --- | --- | --- |
| UNDEFINED | TRANSFER_DST_OPTIMAL | nowy obraz jest inicjalizowy poleceniem transferu | 0 | TRANSFER_WRITE | TOP_OF_PIPE | TRANSFER |
| TRANSFER_DST_OPTIMAL | TRANSFER_SRC_OPTIMAL | zainicjalizowany obraz jest źródłem polecenia transferu (generacje mipmap) | TRANSFER_WRITE | TRANSFER_READ | TRANSFER | TRANSFER |
| TRANSFER_SRC_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz jest odczytywany przez shader fragmentów | TRANSFER_READ | SHADER_READ | TRANSFER | FRAGMENT_SHADER |
| TRANSFER_DST_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz jest odczytywany przez shader fragmentów | TRANSFER_WRITE | SHADER_READ | TRANSFER | FRAGMENT_SHADER |
| UNDEFINED | COLOR_ATTACHMENT_OPTIMAL | obraz jest dołączeniem koloru pierwszy raz z klatce | 0 |  COLOR_ATTACHMENT_WRITE | TOP_OF_PIPE | COLOR_ATTACHMENT_OUTPUT |
| UNDEFINED | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz jest dołączeniem głebi/szablonu pierwszy raz z klatce | 0 |  DEPTH_STENCIL_ATTACHMENT_READ, DEPTH_STENCIL_ATTACHMENT_WRITE | TOP_OF_PIPE | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| DEPTH_STENCIL_ATTACHMENT_OPTIMAL | DEPTH_STENCIL_READ_ONLY_OPTIMAL | obraz staje się dołączeniem głebi/szablonu tylko do odczytu | DEPTH_STENCIL_ATTACHMENT_WRITE |  DEPTH_STENCIL_ATTACHMENT_READ, SHADER_READ | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS | EARLY_FRAGMENT_TESTS, FRAGMENT_SHADER |
| DEPTH_STENCIL_READ_ONLY_OPTIMAL | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz przestaje być dołączeniem głebi/szablonu tylko do odczytu | DEPTH_STENCIL_ATTACHMENT_READ, SHADER_READ | DEPTH_STENCIL_ATTACHMENT_WRITE | EARLY_FRAGMENT_TESTS, FRAGMENT_SHADER | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| COLOR_ATTACHMENT_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz staje się dołączeniem koloru tylko do odczytu | COLOR_ATTACHMENT_WRITE | SHADER_READ | COLOR_ATTACHMENT_OUTPUT | FRAGMENT_SHADER |
| SHADER_READ_ONLY_OPTIMAL | COLOR_ATTACHMENT_OPTIMAL | obraz przestaje być dołączeniem koloru tylko do odczytu | SHADER_READ | COLOR_ATTACHMENT_WRITE | FRAGMENT_SHADER | COLOR_ATTACHMENT_OUTPUT |
| COLOR_ATTACHMENT_OPTIMAL | COLOR_ATTACHMENT_OPTIMAL | obraz jest ponowanie dołączeniem koloru w następnym przebiegu renderowania | COLOR_ATTACHMENT_WRITE | COLOR_ATTACHMENT_READ, COLOR_ATTACHMENT_WRITE | COLOR_ATTACHMENT_OUTPUT | COLOR_ATTACHMENT_OUTPUT |
| DEPTH_STENCIL_ATTACHMENT_OPTIMAL | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz jest ponownie dołączeniem głębi/szablonu w następnym przebiegu renderowania | DEPTH_STENCIL_ATTACHMENT_WRITE | DEPTH_STENCIL_ATTACHMENT_READ, DEPTH_STENCIL_ATTACHMENT_WRITE | LATE_FRAGMENT_TESTS | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| COLOR_ATTACHMENT_OPTIMAL | PRESENT_SRC_KHR | obraz staje się prezentowalny i gotowy do przekazania silnikowi prezentacji | COLOR_ATTACHMENT_WRITE | MEMORY_READ | COLOR_ATTACHMENT_OUTPUT | BOTTOM_OF_PIPE |

##### Metody one_shot_copy_buffer_to_buffer() i one_shot_copy_buffer_to_image()

Metody one_shot_copy_buffer_to_buffer() i one_shot_copy_buffer_to_image() kopiują dane w obrębie GPU z bufora do bufora
lub obrazu używając poleceń transferu vkCmdCopyBuffer() i vkCmdCopyBufferToImage(). Metoda
one_shot_copy_buffer_to_image() wymaga wcześniejszej przejścia układu obrazu do TRANSFER_DST.

Te metody są przeznaczone do użycia wraz z buforem tymczasowym do kopiowanie danych z pamięci CPU do pamięci
DEVICE_LOCAL używając pośredniczącej pamięci HOST_VISIBLE. Pseudokod:

```
1. Stwórz bufor tymczasowy z flagą użycia TRANSFER_SRC (bufer może być używany jako źródło w operacji transferu) i dowiązaną pamięcią HOST_VISIBLE,
2. Mapuj pamięć bufora tymczasowego funkcją vkMapMemory(),
3. Skopiuj pamięć CPU do pamięci HOST_VISIBLE bufora tymczasowego,
4. Odmapuj pamięć bufora tymczasowego funkcją vkUpmapMemory(),
5. Jeśli kopiowanie do obrazu, to zmień jego układ z UNDEFINED do TRANSFER_DST metodą one_shot_transition_image_layout(),
6. Skopiuj pamięć HOST_VISIBLE bufora tymczasowego do pamięci DEVICE_LOCAL bufora lub obrazu używając bufora poleceń one-shot,
7. Zniszcz bufor tymczasowy i jego pamięć.
```

##### Metoda one_shot_generate_mipmaps()

Metoda generate_mipmaps() generuje poziomy mipmap dla tekstur 2D. Baza zasobów nie przechowuje mipmap, dlatego metoda
jest wywoływania po transferze danych zasobu obrazu do pierwszego poziomu mipmapy obrazu w celu automatycznej generacji
reszty poziomów. Metoda zakłada układ obrazu TRANSFER_DST i pozostawia go w układzie SHADER_READ_ONLY_OPTIMAL.
Pseudokod:

```
MipLevelCount - liczba poziomów mipmap
MipWidth, MipHeight = szerokość oraz wysokość pierwszego poziomu mipmapy
1. Dla każdego poziomu mipmapy i in <1;MipLevelCount):
	1.1. Zmień układ poziomu mipmapy i-1 z TRANSFER_DST_OPTIMAL do TRANSFER_SRC_OPTIMAL,
	1.2. Skopiuj poziom mipmapy i-1 (offset 0,0, rozmar MipWidth, MipHeight) do poziom mipmapy i (offset 0,0, rozmar max(MipWidth,1), max(MipHeight, 1)) funkcją vkCmdBlitImage() używającą filtrowania liniowego,
	1.3. Zmień układ poziomu mipmapy i-1 z TRANSFER_SRC_OPTIMAL do SHADER_READ_ONLY_OPTIMAL,
	1.4. MipWidth, MipHeight = max(MipWidth/2, 1), max(MipHeight/2, 1)
2. Zmień układ ostatniego (MipLevelCount - 1) poziomu mipmapy z TRANSFER_SRC_OPTIMAL do SHADER_READ_ONLY_OPTIMAL.
```

Rozmiar każdego poziomu mipmap jest otrzymywany przez zmniejszenie o połowę każdego wymiaru poprzedniego poziomu aż oba
wymiary osiągną 1 (jeśli obraz nie jest kwadratowy, jeden z wymiarów pozostaje 1 dla reszty poziomów). Wynika z tego, że
maksymalna liczba poziomów mipmap MipLevelCount = 1 + floor(log2(max(MipWidth, MipHeight))).

Przejście układu obrazu w kroku 1.1. jest wymagana przez funkcję vkCmdBlitImage(), która wymaga obrazu źródłowego w
układzie TRANSFER_SRC_OPTIMAL i obrazu docelowego w układzie TRANSFER_DST_OPTIMAL. Przejścia układów obrazu w krokach
1.3. i 2 zapewnia, że obraz jest w układzie SHADER_READ_ONLY_OPTIMAL spodziewanym przez shadery potoku graficznego (
nawet jeśli MipLevelCount to 1 i nie zostały wygenerowane żadne mipmapy).

## objects/device_functions.h

### Funkcje pomocnicze

Metoda pomocnicza device_find_memory_type() jest używana podczas alokowania pamięci dla buferów i obrazów wraz z
funkcjami vkGetBufferMemoryRequirements() i vkGetImageMemoryRequirements() do określenia indeksu sterty pamięci
urządzenia fizycznego wspierającej żądany typ pamięci.

Metoda pomocnicza device_find_supported_format() szuka w wejściowej liście kandydatów formatu (VkFormat) wspieranego
przez urządzenie fizyczne dla rządanego kafelkowania (VkImageTiling) oraz właściwosci formatu (VkFormatFeatureFlags).

Metody pomocnicze device_create_*() tworzą nowe obiekty Vulkan i nazwywają je używając obiektu debug.

### Funkcje tworzące obiekty Vulkan

Metoda device_create_graphics_pipeline() ...

Metody device_begin_rendering() i end_rendering() ...

## objects/sync.h

### Obiekt sync

...

### Klatki w locie

... SEE: Simplifying Vulkan initialization and frame composition

## objects/vertex_stream.h

### Obiekt vertex_stream

...

## objects/unified_geometry_buffer.h

### Obiekt unified_geometry_buffer

...

## objects/unified_uniform_buffer.h

### Obiekt unified_uniform_buffer

...

# Definicje Vulkan

## Dowiązanie koloru

to widok obrazu używany przez potok graficzny do zapisywania końcowych wartości kolorów podczas etapu mieszania kolorów.

## Dowiązanie głębi/szablonu

to widok obrazu używany przez potok graficzny do odczytywania i zapisywania wartości głebi/szablonu podczas testów
głębi/szablonu w etapach wczesnych i późnych testów fragmentów.



# TODO

MORE: multiDrawIndirect: polecenia wielokrotnego rysowania pośredniego MORE: drawIndirectFirstInstance: polecenia
rysowania pośredniego z offsetem indeksu instancji MORE: dynamicRendering: dynamiczne przebiegi renderowania

MORE: warstwy walidacji

MORE: onscreen vs offscreen

MORE: framebuffer attachment

MORE: część globalna i część instancji ujednoliconego bufora uniform, dlatczego podział

MORE: hierarchia obiektów, diagram, opisy

MORE: model obiektów vulkan, creation i enumeration, typy pamięci

TEST: technika filtrowanie anizotropowe, usuń TRANSIENT TEST: technika mipmapy, usuń mipmapy
