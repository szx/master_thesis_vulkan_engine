HIRO odwoływuj się po numerze do listingów
HIRO mniej opisowach kod

What? Why? How? Nieporuszono: podział przestrzeni i culling, multisampling Zagadnienia: wieloplatformowość, automatyczna
generacja kodu, bazy danych Test: obrazy z HOST_VISIBlE Skróty: GPU, indirect rendering - pośrednie renderowania,
fixed-function, buffor, image, texture - sampled image, binding - dowiązanie, bindless rendering - renderowanie bez
dowiązań, update after bind - uaktualnienie po dowiązaniu tiling - kafelkowanie, texel, staging buffer - bufor
tymczasowy, MSAA, shader stage - etap cieniowania, shader invocation - wywołanie shadera, draw call - polecenie
rysowania, texture unit - jednostka teksturujące, device feature - funkcja urządzenia, instance feature - funkcja
instancji, sampler - próbnik sampled image - próbkowany obraz, frame - klatka, command buffer - bufor poleceń layout
qualifier - kwalifikator układu update-after-bind - aktualizacja po dowiązaniu variable-sized descriptor binding -
dowiązanie deskryptora o zmiennej wielkości render state - stan renderowania unified uniform buffer - ujednolicony bufor
uniform unified geometry buffer - ujednolicony bufor geometrii GLSL - OpenGL Shading Language swap chain - łańcuch
wymiany WSI - window system integration framebufer attachment - dołączenie bufora ramki front buffer - bufor przedni
back buffer - bufor tylni presentation engine - silnik prezentacji in-flight frame - klatka w locie, image layout
transition - przejście układu obrazu, execution dependency - zależność wykonania, memory dependency - zależność pamięci
storage buffer - bufor magazynowy

-------------

## Założenia

Implementacji przyświacały następujące:
Niskopoziomowość. ...

## Struktura plików

Wszystkie pliki silnika znajduje się w jednym katalogu głównym.

Katalog główny jest podzielony na mniejsze podkatalogi:

- *assets*: zawierający pliki wejściowe potoku zasobów,
- *src*: kod źródłowy silnika dla języka C,
- *scripts*: kod źródłowy silnika dla języka Python,
- *thirdparty*: kod źródłowy bibliotek zewnętrznych.

Proces budowania stwarza dodatkowe podkatalogi tymczasowe:

- *venv*: środowisko wirtualne interpretera języka Python,
- *cmake-build-debug* & *cmake-build-release*: katalogi budowania

## Scena

Moduł sceny jest odpowiedzialny za wygenerowanie ze sceny listy obiektów renderowania. Struktury:
Scene data... Scene graph... Scene tree... Render cache... Render cache list...

...

## Potok graficzny

Moduł potoku graficznego udostępnia zbiór obiektów pozwalających na użycie bilioteki graficznej Vulkan za pośrednictwem
wygodniejszej dla programisty abstrakcji. ...

## Przebieg renderowania

Moduł przebiegu renderowania jest odpowiedzialny za wyrenderowanie całości bądź części listy renderującej. Przebieg
renderowania nagrywa polecenia do podanego bufora poleceń.
[DIAGRAM]

## Graf renderowania

Moduł grafu renderowania jest odpowiedzialny za stworzenie przebiegów renderowania na podstawie wysokopoziomowego
deklaratywne opisu renderowania dostarczonego przez programistę. ...


# TODO

/vulkan/debug.h Obiekt vulkan_debug pozwala na dodawanie informacji debugujących do obiektów Vulkan. Jest to osiągnętę przy pomocy rozszerzenia VK_EXT_debug_utils.

-------------


-------------
/vulkan/common.h Globalna tablica typów obrazów wspieranych przez silnik:
[TABELA]
Struktura aabb reprezentuje prostokąt ograniczający (ang. axis-aligned bounding box, AABB). Pozwala na obliczenie
najmniejszej i największej pozycji renderowanych wierzchołków sceny, co pozwala na obliczenie domyślnej pozycji kamery w
taki sposób, żeby obejmowała ona całą scenę. Funkcja get_perspective_matrix oblicza macierz rzutu perspektywicznego z
przestrzeni widoku do przestrzeni przycinania (ang. clip space).
[OBRAZEK]

Funkcja get_orthographic_matrix oblicza macierz rzutu prostokątnego z przestrzeni widoku do przestrzeni przycinania (
ang. clip space). Przestrzeń przycinania w Vulkanie jest prawoskrętna z flipped Y.
-------------

Vulkan [... 2d/3d, mipmap (lod), array layers, tiling]
[OBRAZEK]
Oba rodzaje zasobów muszą posiadać dowiązaną alokację pamięci.

Użycie flag dobrze dopasowanych do użycia określonego przez rodzaj bufora jest wskazówką dla sterownika graficznego,
którą może on użyć do bardziej optymalnego wewnętrzne zarządzanie stanem i pamięcią GPU.
[LISTING alloc, create, bind buffer/image]

---
/objects/image.h
[OBRAZEK struktura]
Silnik wspiera osiem rodzajów obrazów:

- swap_chain
- material_base_color, mapowanie tekstur
- material_parameters
- normal_map
- cubemap
- font_bitmap
- offscreen_f16
- offscreen_depth_buffer
- offscreen_r8
  [...obrazy offscreen]
  [TABELA internal]

Obraz składa się z trzech obiektów Vulkan: obraz VkImage, alokacja pamięci VkDeviceMemory i widok obrazu VkImageView.
Vulkan nie pozwala na bezpośrednie używanie VkImage i wymaga utworzenia VkImageView. Stworzenie nowego obrazu wymaga
podania rządanego rodzaju oraz szerokości, wysokości i liczby kanałów. Vulkan pozwala na bezpośrednią specyfikację
kafelkowania obrazu (ang, image tiling). Vulkan wspiera kafelkowanie liniowe, w którym teksele obrazu są szeregowane w
pamięci wierszami (ang. row-major order) podobnie jak w tablicach dwuwymiarowych w języku C. Vulkan wspiera też
kafelkowanie optymalne, w którym teksele obrazu są umieszczone w pamięci w sposób zdefiniowany przez sterownik graficzny
mający na celu bardziej wydajny dostęp do pamięci.
[OBRAZEK tiling]
Silnik używa wyłącznie kafelkowania optymalnego, które jest wydajniejsze od kafelkowania liniowego i jest w czasie
pisania pracy według portalu GPUInfo.org szerzej wspierane. Silnik nie wspiera MSAA - współpraca MSAA z renderowaniem
odroczonym jest możliwa [SRAA], ale wprowadzany przez nie poziom kompilacji implementacji renderowania odroczonego
został uznany za zbyt duży, i dlatego jest poza zakresem tej pracy. Z tego powodu wszystkie obrazy, w tym te służące
jako cele renderowania, , CPU nie używa obrazów używanych przez GPU do renderowania, dlatego też pamięć wszystkich
rodzajów obrazów jest pamięcią DEVICE_LOCAL, co powinno skutkować najszybszym dostępem do obrazów przez GPU. Kopiowanie
danych z CPU do GPU jest ważną operacją pozwalającą na wstępne wypełnienie obrazów danymi załadowanymi z bazy zasobów.
[LISTING]
W przypadku obrazów używanych do mapowania tekstur po skopiowaniu danych do mipmapy poziomu 0 silnik generuje resztę
poziomów mipmap używając serii funkcji vkCmdBlitImage. Użycie tej funkcji wymaga obrazu w formacie wspierającym
filtrowanie liniowe. Dodatkowo ta funkcja może być wykonywana używając tylko kolejki graficznej, dlatego też bufory
poleceń one-shot nie mogą być wykonywane używając tylko kolejki transferowej, mimo możliwej większej wydajności.
[LISTING mipmap]
Format obrazu jest wybierany przy pomocy algorytmu opisanego w poniższym listingu. Algorytm generuje listę formatów
spełniających wymagania specyfikowane przez rodzaj obrazu i liczbą kanałów równą lub większą od liczby kanałów używanej
przez obraz. Ostateczny format to ten z z najmniejszą liczbą kanałów wciąż wspierany przez sterownik graficzny.
[LISTING find_image_format]

----
/objects/buffer.h
[OBRAZEK struktura]
Silnik wyróżnia cztery rodzaje buforów:

- bufor wierzchołków,
- bufor indeksów,
- bufor poleceń rysowania pośredniego,
- bufor uniform.

Bufory wierzchołków, indeksów i poleceń rysowania pośredniego są źródłem danych odczytywanych przez stałe funkcji potoku
graficznego. Bufory uniform są źródłem danych odczytywanych przez shadery. Bufor składa się z dwóch obiektów Vulkan:
VkBuffer i VkDeviceMemory. Rodzaj bufora przekłada się na flagi stosowane podczas tworzenia obiektów Vulkan, co zostało
podsumowane w poniższej tabeli:
rodzaj bufora / flagi użycia bufora (VkBufferUsageFlags) / flagi właściwości pamięci (VkMemoryPropertyFlags)
bufor wierzchołków / TRANSFER_DST | VERTEX_BUFFER / DEVICE_LOCAL bufor indeksów / TRANSFER_DST | INDEX_BUFFER /
DEVICE_LOCAL bufor poleceń rysowania pośredniego / TRANSFER_DST | INDIRECT_BUFFER / HOST_VISIBLE | HOST_COHERENT bufor
uniform / UNIFORM_BUFFER / HOST_VISIBLE | HOST_COHERENT

Kopiowanie danych z CPU do bufora w GPU jest ważną operacją wykonywaną na początku każdej ramki mającą na celu
wypełnienie pamięci GPU danymi używanymi przez polecenia renderowania. Może się ono odbyć na dwa sposoby w zależności od
użytych flag właściwości pamięci. Dla pamięci HOST_VISIBLE silnik używa funkcji vkMapMemory() do uzyskania wskaźnika do
regionu pamięci i bezpośredniego skopiowania pamięci przy użyciu CPU.
[LISTING vkMapMemory]
Dla innych rodzajów pamięci, które nie mogą być bezpośrednio zapisywane przez CPU (w tym DEVICE_LOCAL) silnik używa
bufora tymczasowego i funkcji vkCmdCopyBuffer() w bufore poleceń one-shot.
[LISTING staging]

---

## objects/descriptor.h

### Vulkan

### Silnik

Silnik zgodnie z duchem renderowania bez dowiązań dąży do zmniejszenia liczby alokowanych deskryptorów i eliminacji
dowiązywanie zasobów między poleceniami rysowania.

Tworzona jest jedna pula deskryptorów, która pozwala ona na alokację jednego globalnego zbioru deskryptorów przy pomocy
jednego układu zbioru deskryptorów. Cykl życia tych obiektów jest taki sam - są one stworzone i zniszczone wraz z resztą
stanu renderowania.

Maksymalna liczba deskryptorów buforów zależy od liczby struktur uniform_buffer_struct wykrytych podczas automatycznej
generacji kodu. Maksymalna liczba deskryptorów próbkowanych obrazów zależy od limitu
maxPerStageBindlessDescriptorSampledImages.

Zbiór deskryptorów jest dowiązywany tylko raz wraz z resztą stanu renderowania.

Sposób zarządzania deskryptorami w silniku został przestawiony na poniższym diagramie:
[...set in engine]

## objects/input.h

Dane wejściowe myszy i klawiatury są obsługiwane całkowicie przy pomocy GLFW.

GLFW pozwala na stosowania wirtualnej pozycji kursora. Kursor myszy jest ukryty i jego fizyczna pozycja w oknie jest
centrowana co klatkę - program ma dostęp do wirtualnej pozycji, co pozwala na nieograniczony ruch myszy.

Wirtualna pozycja kursowa jest używana do implemenacji sterowania kamerą.

## objects/textures.h

### Obiekt textures

Obiekt textures zarządza wszystkimi teksturami i materiałami. Metoda update() jest funkcją no-op. Metoda
send_to_device() wysyła obrazy tekstur do GPU. Metody add_texture() i add_material() tworzą nowe tekstury i materiały.
Są one niszczone wraz z instancją obiektu. Funkcja glsl_add_textures() dodaje kwalifikatory układu do kodu GLSL shadera
pozwalające na dostęp do tekstur.

### Tekstura

Tekstura to obraz, który może być próbkowany przez shadery.

W silniku tekstura składa się z następujących elementów:

- zasób tekstury,
- obraz,
- próbnik,
- identyfikator tekstury.

### Tworzenie tekstury

Tekstura jest tworzona przy pomocy metdy add_texture(), której wejściem jest zasób tekstury.

Stworzone tekstury są przechowywane w tablicy mieszającej w strukturze vulkan_textures, której kluczem jest zasób
tekstury. Pozwala to na uniknięcie duplikacji pamięci podczas tworzenia tekstur.

Obraz i próbnik są tworzone na podstawie danych zawartych w zasobie tekstury.

Identyfikator tekstury to 32-bitowa liczba całkowita. Pierwszy identyfikator to zero, każdy następny jest uzyskiwany
poprzez inkrementację. Maksymalna liczba stworzonych tekstur jest równa maksymalnej liczbie deskryptorów próbkowanych
obrazów.

### Dostęp do tekstur w shaderach

Dostęp do tekstur w shaderach odbywa się przy użyciu globalnej tablicy tekstur, która jest pojedyńczą tablicą
deskryptorów próbkowanych obrazów znajdującą się w ostatnim dowiązaniu globalnego zbioru deskryptorów.

Identyfikator tekstury jest indeksem w tej tablicy. Jest on używany do aktualizacji deskryptora obrazem i próbnikiem
tekstury.

Kwalifikatory układu w shaderach GLSL dla tablicy deskryptorów próbkowanych obrazów 2D są mają następującą formę:

```
layout(set = 0, binding = {numer ostatniego dowiązania}) uniform sampler2D textures2D[];
layout(set = 0, binding = {numer ostatniego dowiązania}) uniform samplerCube texturesCube[];
```

Powyższy kod definiuje dwie zmienne shadera, które posiadają identyczne numery zbioru i dowiązania deskryptorów oraz
różne typy zmiennych shadera.

Ta sytuacja jest dozwolona przez specyfikację Vulkana (sekcja **5.6.3. DescriptorSet and Binding Assignment**) z
zastrzeżeniem, że shader może używać jedynie tych zmiennych shadera, których typ odpowiada rodzajowi dowiązanego
deskryptora. Przykładowo, jeśli indeks *i* w tablicy deskryptorów tekstur opisuje teksturę 2D, to dostęp do niej w
shaderze musi się odbywać przy użyciu wyrażenia *textures2D[i]* - użycie wyrażenia *texturesCube[i]* jest
niezdefiniowanym zachowaniem.

Technika ta eliminuje potrzebę tworzenia i zarządzania osobnymi dowiązaniami deskryptorów dla różnych rodzajów tekstur i
pozwala na unifikację próbkowania tekstur - dostęp do tekstury wymaga jedynie wiedzy o jego identyfikatorze *i* i
rodzaju:

```
vec4 tex2DSample = texture(textures2D[i], vec2(0));
vec4 texCubeSample = texture(texturesCube[], vec3(0));
```

### Materiał

W silniku materiał składa się z następujących elementów:

- zasób materiału,
- tekstury materiału:
    - tekstura koloru podstawowego,
    - tekstura metaliczności-chropowatości,
    - teksura normalnych,
- identyfikator materiału.

### Tworzenie materiału

Materiał jest tworzony przy pomocy metody add_material(), której wejściem jest zasób materiału.

Stworzone materiały, podobnie jak tekstury, są przechowywane w tablicy mieszającej w strukturze vulkan_textures, której
kluczem jest zasób materiału.

Tekstury materiału są tworzone na podstawie danych zawartych w zasobie materiału. Zasób materiału jest także używany do
przechowywania parametrów materiału.

Identyfikator materiału jest 32-bitową liczbą całkowitą. Pierwszy identyfikator to zero, każdy następny jest uzyskiwany
poprzez inkrementację. Maksymalna liczba stworzonych materiałów jest równa stałej MAX_MATERIAL_COUNT.

### Dostęp do materiałów w shaderach

Dostęp do materiałów w shaderach odbywa się przy użyciu części globalnej ujednoliconego bufora uniform. Zawiera on
tablicę struktur *material_helper_element*, w której identyfikator materiału pozwala na dostęp do jego parametrów i
identyfikatorów tekstur:

```
struct material_helper_element {
  uint baseColorTextureId;
  vec4 baseColorFactor;
  uint metallicRoughnessTextureId;
  uint normalMapTextureId;
  float metallicFactor;
  float roughnessFactor;
};
...
material_helper_element materials [MAX_MATERIAL_COUNT];
...
vec4 baseColorFactor = global[globalIdx].materials[materialId].baseColorFactor;
uint baseColorTextureId = global[globalIdx].materials[materialId].baseColorTextureId;
vec4 baseColorSample = texture(textures2D[baseColorTextureId], inTexCoord);
```

## objects/device.h

### Obiekt device

HIRO

Bufor poleceń one-shot może być wypełniony dowolnymi poleceniami graficznymi Vulkan, ale silnik oferuje następujące
metody implementujące podstawowe operacje używane podczas transferu danych:

- one_shot_transition_image_layout(),
- one_shot_copy_buffer_to_buffer(),
- one_shot_copy_buffer_to_image(),
- one_shot_generate_mipmaps().

##### Metoda one_shot_transition_image_layout()

Metoda one_shot_transition_image_layout() zmienia układ całego obrazu - jego wszystkich warstw i poziomów mipmap. Używa
ona do tego metody device_transition_image_layout_command().

##### Układ obrazu

Obrazy są przechowywane w pamięci GPU w układach zdefiniowanych przez sterownik graficzny. Każdy układ ogranicza zbiór
możliwych operacji na obrazie w zamian za optymalizację dozwolonych operacji.

Układ obrazu nie jest tym samym co jego kafelkowanie - rodzaj używanego kafelkowania nie może być zmieniany po
utworzeniu obrazu, a układ obrazu jest zwykle często zmieniany podczas działania programu aby pozwolić GPU na
optymalizację sposobu użycia obrazu.

Przykładowe układy obrazu i dozwolone użycie:

- UNDEFINED: zawartość pamięci obrazu jest niezdefiniowana,
- GENERAL: wszystkie rodzaje dostępu,
- COLOR_ATTACHMENT_OPTIMAL: dołączenie koloru,
- DEPTH_STENCIL_ATTACHMENT_OPTIMAL:  dołączenie głębi/szablonu pozwalające na odczyt (testy głębi i szablonu) i zapis (
  wyjście głębi),
- DEPTH_STENCIL_READ_ONLY_OPTIMAL: dołączenie głębi/szablonu tylko do odczytu,
- SHADER_READ_ONLY_OPTIMAL: odczyt w shaderach jako próbkowany obraz,
- TRANSFER_SRC_OPTIMAL: obraz źródłowy w poleceniu transferu,
- TRANSFER_DST_OPTIMAL: obraz docelowy w poleceniu transferu,
- PRESENT_SRC_KHR: prezentowanie obrazu.

W przeciwieństwie do poprzednich API takich jak OpenGL, Vulkan nie zmienia automatycznie układu obrazu, co zmusza
programistę do samodzielnego śledzenia stanu układu obrazów i wykonywania przejść na poprawny układ przed użyciem ich
przez polecenia.

Graf renderowania jest odpowiedzialyn za śledzenie stanu układu obrazów na przestrzeni klatki i jest używany do
nagrywania barier pamięci obrazu gwarantujących odpowiednie przejścia układu obrazów.

##### Metoda device_transition_image_layout_command()

Metoda device_transition_image_layout_command() nagrywa barierę pamięci obrazu przeprowadzającą przejście ze *starego
układu obrazu* na *nowy układ obrazu*. Użycie bariery potoku wymaga zdefiniowania całej zależności pamięci, dlatego
każde przejście układu obrazów wymaga zdefiniowania jak dokładnie obraz będzie używany po przejściu i zakodowania tej
wiedzy używając źródłowych i docelowych etapów potoku oraz zakresów dostępów.

Poniższa tabela ilustruje logikę przejść używanych przez silnik:

| stary układ obrazu | nowy układ obrazu | uzycie obrazu po przejściu | źródłowy etap potoku | docelowy etap potoku | źródłowy zakres dostępu | docelowy zakres dostępu |
| --- | --- | --- | --- | --- | --- | --- |
| UNDEFINED | TRANSFER_DST_OPTIMAL | nowy obraz jest inicjalizowy poleceniem transferu | 0 | TRANSFER_WRITE | TOP_OF_PIPE | TRANSFER |
| TRANSFER_DST_OPTIMAL | TRANSFER_SRC_OPTIMAL | zainicjalizowany obraz jest źródłem polecenia transferu (generacje mipmap) | TRANSFER_WRITE | TRANSFER_READ | TRANSFER | TRANSFER |
| TRANSFER_SRC_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz jest odczytywany przez shader fragmentów | TRANSFER_READ | SHADER_READ | TRANSFER | FRAGMENT_SHADER |
| TRANSFER_DST_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz jest odczytywany przez shader fragmentów | TRANSFER_WRITE | SHADER_READ | TRANSFER | FRAGMENT_SHADER |
| UNDEFINED | COLOR_ATTACHMENT_OPTIMAL | obraz jest dołączeniem koloru pierwszy raz z klatce | 0 |  COLOR_ATTACHMENT_WRITE | TOP_OF_PIPE | COLOR_ATTACHMENT_OUTPUT |
| UNDEFINED | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz jest dołączeniem głebi/szablonu pierwszy raz z klatce | 0 |  DEPTH_STENCIL_ATTACHMENT_READ, DEPTH_STENCIL_ATTACHMENT_WRITE | TOP_OF_PIPE | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| DEPTH_STENCIL_ATTACHMENT_OPTIMAL | DEPTH_STENCIL_READ_ONLY_OPTIMAL | obraz staje się dołączeniem głebi/szablonu tylko do odczytu | DEPTH_STENCIL_ATTACHMENT_WRITE |  DEPTH_STENCIL_ATTACHMENT_READ, SHADER_READ | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS | EARLY_FRAGMENT_TESTS, FRAGMENT_SHADER |
| DEPTH_STENCIL_READ_ONLY_OPTIMAL | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz przestaje być dołączeniem głebi/szablonu tylko do odczytu | DEPTH_STENCIL_ATTACHMENT_READ, SHADER_READ | DEPTH_STENCIL_ATTACHMENT_WRITE | EARLY_FRAGMENT_TESTS, FRAGMENT_SHADER | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| COLOR_ATTACHMENT_OPTIMAL | SHADER_READ_ONLY_OPTIMAL | obraz staje się dołączeniem koloru tylko do odczytu | COLOR_ATTACHMENT_WRITE | SHADER_READ | COLOR_ATTACHMENT_OUTPUT | FRAGMENT_SHADER |
| SHADER_READ_ONLY_OPTIMAL | COLOR_ATTACHMENT_OPTIMAL | obraz przestaje być dołączeniem koloru tylko do odczytu | SHADER_READ | COLOR_ATTACHMENT_WRITE | FRAGMENT_SHADER | COLOR_ATTACHMENT_OUTPUT |
| COLOR_ATTACHMENT_OPTIMAL | COLOR_ATTACHMENT_OPTIMAL | obraz jest ponowanie dołączeniem koloru w następnym przebiegu renderowania | COLOR_ATTACHMENT_WRITE | COLOR_ATTACHMENT_READ, COLOR_ATTACHMENT_WRITE | COLOR_ATTACHMENT_OUTPUT | COLOR_ATTACHMENT_OUTPUT |
| DEPTH_STENCIL_ATTACHMENT_OPTIMAL | DEPTH_STENCIL_ATTACHMENT_OPTIMAL | obraz jest ponownie dołączeniem głębi/szablonu w następnym przebiegu renderowania | DEPTH_STENCIL_ATTACHMENT_WRITE | DEPTH_STENCIL_ATTACHMENT_READ, DEPTH_STENCIL_ATTACHMENT_WRITE | LATE_FRAGMENT_TESTS | EARLY_FRAGMENT_TESTS, LATE_FRAGMENT_TESTS |
| COLOR_ATTACHMENT_OPTIMAL | PRESENT_SRC_KHR | obraz staje się prezentowalny i gotowy do przekazania silnikowi prezentacji | COLOR_ATTACHMENT_WRITE | MEMORY_READ | COLOR_ATTACHMENT_OUTPUT | BOTTOM_OF_PIPE |

##### Metody one_shot_copy_buffer_to_buffer() i one_shot_copy_buffer_to_image()

Metody one_shot_copy_buffer_to_buffer() i one_shot_copy_buffer_to_image() kopiują dane w obrębie GPU z bufora do bufora
lub obrazu używając poleceń transferu vkCmdCopyBuffer() i vkCmdCopyBufferToImage(). Metoda
one_shot_copy_buffer_to_image() wymaga wcześniejszej przejścia układu obrazu do TRANSFER_DST.

Te metody są przeznaczone do użycia wraz z buforem tymczasowym do kopiowanie danych z pamięci CPU do pamięci
DEVICE_LOCAL używając pośredniczącej pamięci HOST_VISIBLE. Pseudokod:

```
1. Stwórz bufor tymczasowy z flagą użycia TRANSFER_SRC (bufer może być używany jako źródło w operacji transferu) i dowiązaną pamięcią HOST_VISIBLE,
2. Mapuj pamięć bufora tymczasowego funkcją vkMapMemory(),
3. Skopiuj pamięć CPU do pamięci HOST_VISIBLE bufora tymczasowego,
4. Odmapuj pamięć bufora tymczasowego funkcją vkUpmapMemory(),
5. Jeśli kopiowanie do obrazu, to zmień jego układ z UNDEFINED do TRANSFER_DST metodą one_shot_transition_image_layout(),
6. Skopiuj pamięć HOST_VISIBLE bufora tymczasowego do pamięci DEVICE_LOCAL bufora lub obrazu używając bufora poleceń one-shot,
7. Zniszcz bufor tymczasowy i jego pamięć.
```

##### Metoda one_shot_generate_mipmaps()

Metoda generate_mipmaps() generuje poziomy mipmap dla tekstur 2D. Baza zasobów nie przechowuje mipmap, dlatego metoda
jest wywoływania po transferze danych zasobu obrazu do pierwszego poziomu mipmapy obrazu w celu automatycznej generacji
reszty poziomów. Metoda zakłada układ obrazu TRANSFER_DST i pozostawia go w układzie SHADER_READ_ONLY_OPTIMAL.
Pseudokod:

```
MipLevelCount - liczba poziomów mipmap
MipWidth, MipHeight = szerokość oraz wysokość pierwszego poziomu mipmapy
1. Dla każdego poziomu mipmapy i in <1;MipLevelCount):
	1.1. Zmień układ poziomu mipmapy i-1 z TRANSFER_DST_OPTIMAL do TRANSFER_SRC_OPTIMAL,
	1.2. Skopiuj poziom mipmapy i-1 (offset 0,0, rozmar MipWidth, MipHeight) do poziom mipmapy i (offset 0,0, rozmar max(MipWidth,1), max(MipHeight, 1)) funkcją vkCmdBlitImage() używającą filtrowania liniowego,
	1.3. Zmień układ poziomu mipmapy i-1 z TRANSFER_SRC_OPTIMAL do SHADER_READ_ONLY_OPTIMAL,
	1.4. MipWidth, MipHeight = max(MipWidth/2, 1), max(MipHeight/2, 1)
2. Zmień układ ostatniego (MipLevelCount - 1) poziomu mipmapy z TRANSFER_SRC_OPTIMAL do SHADER_READ_ONLY_OPTIMAL.
```

Rozmiar każdego poziomu mipmap jest otrzymywany przez zmniejszenie o połowę każdego wymiaru poprzedniego poziomu aż oba
wymiary osiągną 1 (jeśli obraz nie jest kwadratowy, jeden z wymiarów pozostaje 1 dla reszty poziomów). Wynika z tego, że
maksymalna liczba poziomów mipmap MipLevelCount = 1 + floor(log2(max(MipWidth, MipHeight))).

Przejście układu obrazu w kroku 1.1. jest wymagana przez funkcję vkCmdBlitImage(), która wymaga obrazu źródłowego w
układzie TRANSFER_SRC_OPTIMAL i obrazu docelowego w układzie TRANSFER_DST_OPTIMAL. Przejścia układów obrazu w krokach
1.3. i 2 zapewnia, że obraz jest w układzie SHADER_READ_ONLY_OPTIMAL spodziewanym przez shadery potoku graficznego (
nawet jeśli MipLevelCount to 1 i nie zostały wygenerowane żadne mipmapy).

## objects/device_functions.h

### Funkcje pomocnicze

Metoda pomocnicza device_find_memory_type() jest używana podczas alokowania pamięci dla buferów i obrazów wraz z
funkcjami vkGetBufferMemoryRequirements() i vkGetImageMemoryRequirements() do określenia indeksu sterty pamięci
urządzenia fizycznego wspierającej żądany typ pamięci.

Metoda pomocnicza device_find_supported_format() szuka w wejściowej liście kandydatów formatu (VkFormat) wspieranego
przez urządzenie fizyczne dla rządanego kafelkowania (VkImageTiling) oraz właściwosci formatu (VkFormatFeatureFlags).

Metody pomocnicze device_create_*() tworzą nowe obiekty Vulkan i nazwywają je używając obiektu debug.

### Funkcje tworzące obiekty Vulkan

Metoda device_create_graphics_pipeline() ...

Metody device_begin_rendering() i end_rendering() ...

## objects/sync.h

### Obiekt sync

...

### Klatki w locie

... SEE: Simplifying Vulkan initialization and frame composition

## objects/vertex_stream.h

### Obiekt vertex_stream

...

## objects/unified_geometry_buffer.h

### Obiekt unified_geometry_buffer

...

## objects/unified_constant_buffer.h

### Obiekt unified_constant_buffer

...

# Definicje Vulkan

## Dołączenie koloru

to widok obrazu używany przez potok graficzny do zapisywania końcowych wartości kolorów podczas etapu mieszania kolorów.

## Dołączenie głębi/szablonu

to widok obrazu używany przez potok graficzny do odczytywania i zapisywania wartości głebi/szablonu podczas testów
głębi/szablonu w etapach wczesnych i późnych testów fragmentów.



# TODO

MORE: multiDrawIndirect: polecenia wielokrotnego rysowania pośredniego MORE: drawIndirectFirstInstance: polecenia
rysowania pośredniego z offsetem indeksu instancji MORE: dynamicRendering: dynamiczne przebiegi renderowania

HIRO: debug_printf

MORE: warstwy walidacji

MORE: onscreen vs offscreen

MORE: framebuffer attachment

MORE: część globalna i część instancji ujednoliconego bufora uniform, dlatczego podział

MORE: hierarchia obiektów, diagram, opisy

MORE: model obiektów vulkan, creation i enumeration, typy pamięci
