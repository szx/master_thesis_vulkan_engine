const char *c_parser_ast_node_type_debug_str(c_parser_ast_node_type value) {
  switch (value) {
  case TranslationUnit:
    return "TranslationUnit";
  case LanguageLinkage:
    return "LanguageLinkage";
  case ArgumentExpressionList:
    return "ArgumentExpressionList";
  case ParameterList:
    return "ParameterList";
  case EnumeratorDeclarationList:
    return "EnumeratorDeclarationList";
  case StructOrUnionDeclarationList:
    return "StructOrUnionDeclarationList";
  case InitializerList:
    return "InitializerList";
  case CompoundStatement:
    return "CompoundStatement";
  case String:
    return "String";
  case Identifier:
    return "Identifier";
  case MacroIdentifier:
    return "MacroIdentifier";
  case IntegerDec:
    return "IntegerDec";
  case IntegerOct:
    return "IntegerOct";
  case IntegerHex:
    return "IntegerHex";
  case TypeName:
    return "TypeName";
  case CompoundLiteral:
    return "CompoundLiteral";
  case PreprocessorDirective:
    return "PreprocessorDirective";
  case PreprocessorDirectiveBody:
    return "PreprocessorDirectiveBody";
  case PreprocessorMacroCall:
    return "PreprocessorMacroCall";
  case Declaration:
    return "Declaration";
  case DeclarationSpecifiers:
    return "DeclarationSpecifiers";
  case DeclaratorAndInitializer:
    return "DeclaratorAndInitializer";
  case DeclaratorAndInitializerList:
    return "DeclaratorAndInitializerList";
  case IdentifierDeclarator:
    return "IdentifierDeclarator";
  case ArrayDeclarator:
    return "ArrayDeclarator";
  case FunctionDeclaration:
    return "FunctionDeclaration";
  case EnumerationDeclaration:
    return "EnumerationDeclaration";
  case EnumeratorDeclaration:
    return "EnumeratorDeclaration";
  case StructDeclaration:
    return "StructDeclaration";
  case UnionDeclaration:
    return "UnionDeclaration";
  case BitFieldDeclaration:
    return "BitFieldDeclaration";
  case FunctionPointerDeclaration:
    return "FunctionPointerDeclaration";
  case TypedefStructDeclaration:
    return "TypedefStructDeclaration";
  case TypedefUnionDeclaration:
    return "TypedefUnionDeclaration";
  case TypedefEnumDeclaration:
    return "TypedefEnumDeclaration";
  case TypedefTypeDeclaration:
    return "TypedefTypeDeclaration";
  case TypedefFunctionPointerDeclaration:
    return "TypedefFunctionPointerDeclaration";
  case FunctionPointerDeclarationSpecifiers:
    return "FunctionPointerDeclarationSpecifiers";
  case Ellipsis:
    return "Ellipsis";
  case FunctionDefinition:
    return "FunctionDefinition";
  case EmptyStatement:
    return "EmptyStatement";
  case LabelStatement:
    return "LabelStatement";
  case CaseStatement:
    return "CaseStatement";
  case DefaultStatement:
    return "DefaultStatement";
  case ReturnStatement:
    return "ReturnStatement";
  case ContinueStatement:
    return "ContinueStatement";
  case BreakStatement:
    return "BreakStatement";
  case GotoStatement:
    return "GotoStatement";
  case IfStatement:
    return "IfStatement";
  case SwitchStatement:
    return "SwitchStatement";
  case ForStatement:
    return "ForStatement";
  case WhileStatement:
    return "WhileStatement";
  case DoWhileStatement:
    return "DoWhileStatement";
  case SubscriptAccess:
    return "SubscriptAccess";
  case MemberAccess:
    return "MemberAccess";
  case PointerAccess:
    return "PointerAccess";
  case FunctionCall:
    return "FunctionCall";
  case Cast:
    return "Cast";
  case Deref:
    return "Deref";
  case Ref:
    return "Ref";
  case Sizeof:
    return "Sizeof";
  case BitOr:
    return "BitOr";
  case BitAnd:
    return "BitAnd";
  case BitXor:
    return "BitXor";
  case BitShiftLeft:
    return "BitShiftLeft";
  case BitShiftRight:
    return "BitShiftRight";
  case BitNot:
    return "BitNot";
  case Plus:
    return "Plus";
  case Minus:
    return "Minus";
  case Inc:
    return "Inc";
  case Dec:
    return "Dec";
  case Add:
    return "Add";
  case Sub:
    return "Sub";
  case Mul:
    return "Mul";
  case Div:
    return "Div";
  case Mod:
    return "Mod";
  case Assign:
    return "Assign";
  case AssignAdd:
    return "AssignAdd";
  case AssignSub:
    return "AssignSub";
  case AssignMul:
    return "AssignMul";
  case AssignDiv:
    return "AssignDiv";
  case AssignMod:
    return "AssignMod";
  case AssignBitOr:
    return "AssignBitOr";
  case AssignBitAnd:
    return "AssignBitAnd";
  case AssignBitXor:
    return "AssignBitXor";
  case AssignBitLeftShift:
    return "AssignBitLeftShift";
  case AssignBitRightShift:
    return "AssignBitRightShift";
  case Or:
    return "Or";
  case And:
    return "And";
  case Not:
    return "Not";
  case Ternary:
    return "Ternary";
  case EQ:
    return "EQ";
  case NE:
    return "NE";
  case LT:
    return "LT";
  case GT:
    return "GT";
  case LE:
    return "LE";
  case GE:
    return "GE";
  default:
    return "UNKNOWN";
  }
}
const char *c_parser_error_type_debug_str(c_parser_error_type value) {
  switch (value) {
  case SyntaxError:
    return "SyntaxError";
  case UnclosedComment:
    return "UnclosedComment";
  case UnclosedString:
    return "UnclosedString";
  case MissingSemicolonAfterStatement:
    return "MissingSemicolonAfterStatement";
  default:
    return "UNKNOWN";
  }
}
