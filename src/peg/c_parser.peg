%prefix "c_parser"

%auxil "c_parser_state *"
%value "c_parser_ast_node *"

%header {
  #include "../c_parser_internal.h"
  c_parser_state c_parser_execute(char *source);
}

%source {
  #define PCC_GETCHAR(auxil) c_parser_getchar((auxil))
  #define PCC_ERROR(auxil) c_parser_handle_syntax_error((auxil))
  //static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  //#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)

}

program <-
  _ l:statement_list _ EOF { $$ = l; }
/ _ EOF { $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_StatementList, c_parser_str_range_init($0s, $0e)); }

statement_list <-
  s:statement _ l:statement_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, s);
  }
/ s:statement
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_StatementList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, s);
  }

statement <-
  e:compound_statement { $$ = e; }
/ e:expression_statement { $$ = e; }
## TODO: More statements ##

compound_statement <-
  '{' _ '}' { $$ = c_parser_ast_node_init_terminal(auxil, c_parser_ast_node_type_CompoundStatement, c_parser_str_range_init($0s, $0e)); }
/ '{' b:compound_statement_list '}' { $$ = b; }

compound_statement_list <-
  i:compound_item _ l:compound_statement_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, i);
  }
/ i:compound_item
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_CompoundStatement, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, i);
  }

compound_item <-
  s:statement { $$ = s; }
## TODO: Declaration ##

expression_statement <-
  _ e:expression _ ';' { $$ = e; }
/ _ e:expression _ { c_parser_handle_error(auxil, c_parser_error_type_MissingSemicolonAfterExpression, c_parser_str_range_init($0s, $0e)); }

expression <-
  e:assignment_expression { $$ = e; }

assignment_expression <-
  e:unary_expression _ '=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Assign, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '+=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignAdd, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '-=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignSub, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '*=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignMul, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '/=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignDiv, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '%=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignMod, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '|=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignBitOr, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '&=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignBitAnd, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '^=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignBitXor, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '<<=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignBitLeftShift, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '>>=' _ l:assignment_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_AssignBitRightShift, c_parser_str_range_init($0s, $0e), e, l); }
/ e:arithmetic_expression { $$ = e; } ## TODO: Conditional expressions ##

arithmetic_expression <-
  e:term { $$ = e; }

term <-
  l:term _ '+' _ r:factor { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Add, c_parser_str_range_init($0s, $0e), l, r); }
/ l:term _ '-' _ r:factor { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Sub, c_parser_str_range_init($0s, $0e), l, r); }
/ e:factor                { $$ = e; }

factor <-
  l:factor _ '*' _ r:unary_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Mul, c_parser_str_range_init($0s, $0e), l, r); }
/ l:factor _ '/' _ r:unary_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Div, c_parser_str_range_init($0s, $0e), l, r); }
/ l:factor _ '%' _ r:unary_expression { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Mod, c_parser_str_range_init($0s, $0e), l, r); }
/ e:unary_expression                  { $$ = e; }

unary_expression <-
  '++' _ e:unary_expression { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ '--' _ e:unary_expression { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ e:unary_expression _ '++' { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ e:unary_expression _ '--' { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ '+' _ e:unary_expression { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Plus, c_parser_str_range_init($0s, $0e), e); }
/ '-' _ e:unary_expression { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Minus, c_parser_str_range_init($0s, $0e), e); }
/ e:postfix_expression { $$ = e; }

argument_expression_list <-
  e:assignment_expression _ ',' _ l:argument_expression_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, e);
  }
/ e:assignment_expression
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_ArgumentExpressionList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, e);
  }

postfix_expression <-
  e:postfix_expression _ '[' _ i:expression _ ']' { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_SubscriptAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '.' _ i:identifier { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_MemberAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '->' _ i:identifier { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_PointerAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '(' _ ')' { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_FunctionCall, c_parser_str_range_init($0s, $0e), e); }
/ e:postfix_expression _ '(' _ i:argument_expression_list _ ')' { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_FunctionCall, c_parser_str_range_init($0s, $0e), e, i); }
/ e:primary_expression { $$ = e; }

primary_expression <-
  e:identifier { $$ = e; }
## TODO: Strings ##
/ e:number { $$ = e; }
/ '(' _ e:expression _ ')' { $$ = e; }

identifier <-
  IDENT(IDENT/DEC)* { $$ = c_parser_ast_node_init_terminal(auxil, c_parser_ast_node_type_Identifier, c_parser_str_range_init($0s, $0e)); }

number <-
  DEC+ { $$ = c_parser_ast_node_init_terminal(auxil, c_parser_ast_node_type_Integer, c_parser_str_range_init($0s, $0e)); }
## TODO floats ##

## TODO keywords ##

DEC <- [0-9]
IDENT <- [a-zA-Z_]

_ <- ( whitespace / comment )*

comment <-
  '//' ( !EOL . )* EOL { c_parser_handle_comment(auxil, c_parser_str_range_init($0s, $0e)); }
/ '/*' ( !'*/' . )* '*/' { c_parser_handle_comment(auxil, c_parser_str_range_init($0s, $0e)); }
/ '/*' ( !'*/' . )* { c_parser_handle_error(auxil, c_parser_error_type_UnclosedComment, c_parser_str_range_init($0s, $0e)); }

whitespace <- ( blank / EOL )
blank <- [ \t\v\f]
EOL <- '\n' / '\r\n' / '\r'
EOF <- !.

%%
// Returns parse state after parsing source text.
c_parser_state c_parser_execute(char *source) {
  c_parser_state state = c_parser_state_init(source);
  c_parser_context_t *ctx = c_parser_create(&state);
  c_parser_ast_node *ast;
  int ret = c_parser_parse(ctx, &ast);
  state.programNode = ast;
  c_parser_destroy(ctx);
  if (ret) {
    state.isValid = false;
  }
  return state;
}