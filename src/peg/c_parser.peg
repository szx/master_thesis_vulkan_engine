%prefix "c_parser"

%auxil "c_parser_state *"
%value "c_parser_ast_node *"

%header {
  #include "../c_parser_internal.h"
  c_parser_state c_parser_execute(char *source);
}

%source {
  #define PCC_GETCHAR(auxil) c_parser_getchar((auxil))
  #define PCC_ERROR(auxil) c_parser_handle_syntax_error((auxil))
#if 0
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)
#endif
}

program <-
  _ l:translation_unit _ EOF { $$ = l; }
/ _ EOF { $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_TranslationUnit, c_parser_str_range_init($0s, $0e)); }

translation_unit <-
  s:external_declaration _ l:translation_unit
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, s);
  }
/ _ EOF { $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_TranslationUnit, c_parser_str_range_init($0s, $0e)); }


external_declaration <-
  e:preprocessor_definition { $$ = e; }
/ e:function_definition { $$ = e; }
/ e:declaration { $$ = e; }

preprocessor_definition <-
  '#' blank* i:identifier blank* b:preprocessor_definition_body EOL { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_PreprocessorDirective, c_parser_str_range_init($0s, $0e), i, b); }
/ '#' blank* i:identifier blank* EOL { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_PreprocessorDirective, c_parser_str_range_init($0s, $0e), i); }

preprocessor_definition_body <-
  ('\\' EOL / !EOL .)* { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_PreprocessorDirectiveBody, c_parser_str_range_init($0s, $0e)); }

function_definition <-
  s:declaration_specifiers _ d:declarator _ '(' _ p:parameter_list _ ')' _ e:compound_statement { $$ = c_parser_ast_node_init_4(auxil, c_parser_ast_node_type_FunctionDefinition, c_parser_str_range_init($0s, $0e), s, d, p, e); }

parameter_list <-
  e:parameter_declaration _ ',' _ l:parameter_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, e);
  }
/ e:parameter_declaration
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_ParameterList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, e);
  }

parameter_declaration <-
  s:declaration_specifiers _ i:init_declarator { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Declaration, c_parser_str_range_init($0s, $0e), s, i); }


statement <-
  e:compound_statement { $$ = e; }
/ e:expression_statement { $$ = e; }
## TODO: More statements ##

compound_statement <-
  '{' _ '}' { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_CompoundStatement, c_parser_str_range_init($0s, $0e)); }
/ '{'_ b:compound_statement_list _ '}' { $$ = b; }

compound_statement_list <-
  i:compound_item _ l:compound_statement_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, i);
  }
/ i:compound_item
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_CompoundStatement, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, i);
  }

compound_item <-
  d:declaration { $$ = d; }
/ s:statement { $$ = s; }

expression_statement <-
  _ e:expression _ ';' { $$ = e; }
/ _ e:expression _ { c_parser_handle_error(auxil, c_parser_error_type_MissingSemicolonAfterExpression, c_parser_str_range_init($0s, $0e)); }

## NOTE: We forbid declaration without init_declarator. ##
## NOTE: We forbid init_declarator_list. ##
declaration <-
  e:typedef_declaration _ ";" { $$ = e; }
/ e:enum_declaration _ ";" { $$ = e; }
/ e:struct_declaration  _ ";" { $$ = e; }
/ s:declaration_specifiers _ i:init_declarator _ ';' { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Declaration, c_parser_str_range_init($0s, $0e), s, i); }
/ s:declaration_specifiers _ d:declarator _ '(' _ p:parameter_list _ ')' _ ';' { $$ = c_parser_ast_node_init_3(auxil, c_parser_ast_node_type_FunctionDeclaration, c_parser_str_range_init($0s, $0e), s, d, p); }
## TODO: struct/union declaration. ##

typedef_declaration <-
  kw_typedef _ kw_struct _ tag:identifier _ alias:identifier { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_TypedefStructDeclaration, c_parser_str_range_init($0s, $0e), tag, alias); }
/ kw_typedef _ d:struct_declaration _ alias:identifier { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_TypedefStructDeclaration, c_parser_str_range_init($0s, $0e), d, alias); }
/ kw_typedef _ d:enum_declaration _ alias:identifier { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_TypedefEnumDeclaration, c_parser_str_range_init($0s, $0e), d, alias); }

enum_declaration <-
  kw_enum _ tag:identifier _ "{" _ e:enumerator_list  _ "}" { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_EnumerationDeclaration, c_parser_str_range_init($0s, $0e), tag, e); }

enumerator_list <-
  e:enumerator_declaration _ ',' _ l:enumerator_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, e);
  }
/ e:enumerator_declaration (_ ',')?
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_EnumeratorDeclarationList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, e);
  }

enumerator_declaration <-
  e:identifier _ '=' _ i:initializer { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_EnumeratorDeclaration, c_parser_str_range_init($0s, $0e), e, i); }
/ e:identifier { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_EnumeratorDeclaration, c_parser_str_range_init($0s, $0e), e); }

struct_declaration <-
  kw_struct _ tag:identifier _ "{" _ e:struct_declaration_list  _ "}" { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_StructDeclaration, c_parser_str_range_init($0s, $0e), tag, e); }

struct_declaration_list <-
  e:declaration _ l:struct_declaration_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, e);
  }
/ e:declaration
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_StructDeclarationList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, e);
  }

## TODO: We forbid declaration_specifiers for arrays, structs etc. ##
declaration_specifiers <-
  storage_class_specifier? _ type_qualifier? _ identifier (_ '*')* { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_DeclarationSpecifiers, c_parser_str_range_init($0s, $0e)); }

storage_class_specifier <-
  kw_static
/ kw_extern

type_qualifier <-
  kw_const
/ kw_restrict
/ kw_volatile

init_declarator <-
  d:declarator _ '=' _ i:initializer { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_DeclaratorAndInitializer, c_parser_str_range_init($0s, $0e), d, i); }
/ d:declarator { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_DeclaratorAndInitializer, c_parser_str_range_init($0s, $0e), d); }

declarator <-
  d:declarator _ '[' _ ']' { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_ArrayDeclarator, c_parser_str_range_init($0s, $0e), d); }
/ d:declarator _ '[' _ i:expression _ ']' { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_ArrayDeclarator, c_parser_str_range_init($0s, $0e), d, i); }
/ e:identifier { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_IdentifierDeclarator, c_parser_str_range_init($0s, $0e)); }

initializer <-
  e:assignment_expression { $$ = e; }

expression <-
  e:assignment_expression { $$ = e; }

assignment_expression <-
  e:unary_expression _ '=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Assign, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '+=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignAdd, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '-=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignSub, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '*=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignMul, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '/=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignDiv, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '%=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignMod, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '|=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignBitOr, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '&=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignBitAnd, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '^=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignBitXor, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '<<=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignBitLeftShift, c_parser_str_range_init($0s, $0e), e, l); }
/ e:unary_expression _ '>>=' _ l:assignment_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_AssignBitRightShift, c_parser_str_range_init($0s, $0e), e, l); }
/ e:arithmetic_expression { $$ = e; }

## TODO: Conditional expressions ##
arithmetic_expression <-
  e:additive_expression { $$ = e; }

additive_expression <-
  l:additive_expression _ '+' _ r:multiplicative_expression  { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Add, c_parser_str_range_init($0s, $0e), l, r); }
/ l:additive_expression _ '-' _ r:multiplicative_expression  { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Sub, c_parser_str_range_init($0s, $0e), l, r); }
/ e:multiplicative_expression                 { $$ = e; }

multiplicative_expression  <-
  l:multiplicative_expression  _ '*' _ r:cast_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Mul, c_parser_str_range_init($0s, $0e), l, r); }
/ l:multiplicative_expression  _ '/' _ r:cast_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Div, c_parser_str_range_init($0s, $0e), l, r); }
/ l:multiplicative_expression  _ '%' _ r:cast_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Mod, c_parser_str_range_init($0s, $0e), l, r); }
/ e:cast_expression                  { $$ = e; }

cast_expression <-
  '(' _ t:cast_type_name _ ')' e:cast_expression { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_Cast, c_parser_str_range_init($0s, $0e), t, e); }
/ e:unary_expression { $$ = e; }

## NOTE: PEGs do not support lexical state, but our parser does not aim to be compatible with ANSI C.##
## NOTE: We assume that type name is collection of identifiers and pointers. ##
## NOTE: Fails for sizeof without parenthesis if type_name has no space - sizeof(point)(1) resolves to FunctionCall ##
cast_type_name <-
  ( (identifier / '*') _ )+ { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_TypeName, c_parser_str_range_init($0s, $0e)); }

unary_expression <-
  '++' _ e:unary_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ '--' _ e:unary_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ e:unary_expression _ '++' { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ e:unary_expression _ '--' { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ '+' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Plus, c_parser_str_range_init($0s, $0e), e); }
/ '-' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Minus, c_parser_str_range_init($0s, $0e), e); }
/ '*' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Deref, c_parser_str_range_init($0s, $0e), e); }
/ '&' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Ref, c_parser_str_range_init($0s, $0e), e); }
/ '!' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Not, c_parser_str_range_init($0s, $0e), e); }
/ '~' _ e:cast_expression { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_BitNot, c_parser_str_range_init($0s, $0e), e); }
## NOTE: Our sizeof requires parentheses around expression. ##
/ kw_sizeof _ '(' _ e:cast_expression _ ')' { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_Sizeof, c_parser_str_range_init($0s, $0e), e); }
/ e:postfix_expression { $$ = e; }

argument_expression_list <-
  e:assignment_expression _ ',' _ l:argument_expression_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, e);
  }
/ e:assignment_expression
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_ArgumentExpressionList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, e);
  }

postfix_expression <-
  e:postfix_expression _ '[' _ i:expression _ ']' { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_SubscriptAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '.' _ i:identifier { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_MemberAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '->' _ i:identifier { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_PointerAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression _ '(' _ ')' { $$ = c_parser_ast_node_init_1(auxil, c_parser_ast_node_type_FunctionCall, c_parser_str_range_init($0s, $0e), e); }
/ e:postfix_expression _ '(' _ i:argument_expression_list _ ')' { $$ = c_parser_ast_node_init_2(auxil, c_parser_ast_node_type_FunctionCall, c_parser_str_range_init($0s, $0e), e, i); }
/ e:primary_expression { $$ = e; }

primary_expression <-
  e:identifier { $$ = e; }
/ e:number { $$ = e; }
/ '"' ('\\' . / !'"' .)* '"' { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_String, c_parser_str_range_init($0s, $0e)); }
/ '"' ('\\' . / !'"' .)* { c_parser_handle_error(auxil, c_parser_error_type_UnclosedString, c_parser_str_range_init($0s, $0e)); }
/ '\'' ('\\' . / !'\'' .)* '\'' { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_String, c_parser_str_range_init($0s, $0e)); }
/ '\'' ('\\' . / !'\'' .)* { c_parser_handle_error(auxil, c_parser_error_type_UnclosedString, c_parser_str_range_init($0s, $0e)); }
/ '(' _ e:expression _ ')' { $$ = e; }

identifier <-
  !keyword IDENT(IDENT/DEC)* { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_Identifier, c_parser_str_range_init($0s, $0e)); }

number <-
  '0'[xX]HEX+ { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_IntegerHex, c_parser_str_range_init($0s, $0e)); }
/ '0'OCT+ { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_IntegerOct, c_parser_str_range_init($0s, $0e)); }
/ !'0'DEC+/'0' { $$ = c_parser_ast_node_init_0(auxil, c_parser_ast_node_type_IntegerDec, c_parser_str_range_init($0s, $0e)); }

## TODO floats ##

## TODO keywords ##
keyword <-
  kw_sizeof
/ kw_typedef
/ kw_enum
/ kw_struct
/ kw_static
/ kw_extern
/ kw_restrict
/ kw_volatile

kw_sizeof <- 'sizeof' !(IDENT/DEC)
kw_typedef <- 'typedef' !(IDENT/DEC)
kw_enum <- 'enum' !(IDENT/DEC)
kw_struct <- 'struct' !(IDENT/DEC)
kw_static <- 'static' !(IDENT/DEC)
kw_extern <- 'extern' !(IDENT/DEC)
kw_const <- 'const' !(IDENT/DEC)
kw_restrict <- 'restrict' !(IDENT/DEC)
kw_volatile <- 'volatile' !(IDENT/DEC)

DEC <- [0-9]
OCT <- [0-7]
HEX <- [0-9a-fA-F]
IDENT <- [a-zA-Z_]

_ <- ( whitespace / comment )*

comment <-
  '//' ( !EOL . )* EOL { c_parser_handle_comment(auxil, c_parser_str_range_init($0s, $0e)); }
/ '/*' ( !'*/' . )* '*/' { c_parser_handle_comment(auxil, c_parser_str_range_init($0s, $0e)); }
/ '/*' ( !'*/' . )* { c_parser_handle_error(auxil, c_parser_error_type_UnclosedComment, c_parser_str_range_init($0s, $0e)); }

whitespace <- ( blank / EOL )
blank <- [ \t\v\f]
EOL <- '\n' / '\r\n' / '\r'
EOF <- !.

%%
// Returns parse state after parsing source text.
c_parser_state c_parser_execute(char *source) {
  c_parser_state state = c_parser_state_init(source);
  c_parser_context_t *ctx = c_parser_create(&state);
  c_parser_ast_node *ast;
  int ret = c_parser_parse(ctx, &ast);
  state.programNode = ast;
  c_parser_destroy(ctx);
  if (ret) {
    state.isValid = false;
  }
  return state;
}