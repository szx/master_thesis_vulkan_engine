%prefix "c_parser"

%auxil "c_parser_state *"
%value "c_parser_ast_node *"

%header {
  #include "../c_parser_internal.h"
  c_parser_state c_parser_execute(char *source);
}

%source {
  #define PCC_GETCHAR(auxil) c_parser_getchar((auxil))
  //static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  //#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], rule, pos, (int)(length), buffer)

}

program <-
  _ l:statement_list _ EOF { $$ = l; }
/ _ EOF { $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_StatementList, c_parser_str_range_init($0s, $0e)); }

statement_list <-
  s:statement _ l:statement_list
  {
    $$ = l;
    $$->range = c_parser_str_range_init($0s, $0e);
    c_parser_ast_node_push_front($$, s);
  }
/ s:statement
  {
    $$ = c_parser_ast_node_init_variadic(auxil, c_parser_ast_node_type_StatementList, c_parser_str_range_init($0s, $0e));
    c_parser_ast_node_push_front($$, s);
  }

statement <-
  e:expression_statement { $$ = e; }
## TODO: More statements ##

expression_statement <-
  _ e:expression _ ';' { $$ = e; }
/ _ e:expression _ { c_parser_handle_error(auxil, c_parser_error_type_MissingSemicolon, c_parser_str_range_init($0s, $0e)); }

expression <- e:term { $$ = e; }

term <-
  l:term _ '+' _ r:factor { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Add, c_parser_str_range_init($0s, $0e), l, r); }
/ l:term _ '-' _ r:factor { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Sub, c_parser_str_range_init($0s, $0e), l, r); }
/ e:factor                { $$ = e; }

factor <-
  l:factor _ '*' _ r:unary { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Mul, c_parser_str_range_init($0s, $0e), l, r); }
/ l:factor _ '/' _ r:unary { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Div, c_parser_str_range_init($0s, $0e), l, r); }
/ l:factor _ '%' _ r:unary { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_Mod, c_parser_str_range_init($0s, $0e), l, r); }
/ e:unary                  { $$ = e; }

unary <-
  '+' _ e:unary { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Plus, c_parser_str_range_init($0s, $0e), e); }
/ '-' _ e:unary { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Minus, c_parser_str_range_init($0s, $0e), e); }
/ '++' _ e:unary { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ '--' _ e:unary { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ e:unary _ '++' { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Inc, c_parser_str_range_init($0s, $0e), e); }
/ e:unary _ '--' { $$ = c_parser_ast_node_init_unary(auxil, c_parser_ast_node_type_Dec, c_parser_str_range_init($0s, $0e), e); }
/ e:postfix_expression { $$ = e; }

postfix_expression <-
  e:postfix_expression '[' i:expression ']' { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_SubscriptAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression '.' i:identifier { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_MemberAccess, c_parser_str_range_init($0s, $0e), e, i); }
/ e:postfix_expression '->' i:identifier { $$ = c_parser_ast_node_init_binary(auxil, c_parser_ast_node_type_PointerAccess, c_parser_str_range_init($0s, $0e), e, i); }
## TODO: Function call ##
/ e:primary_expression { $$ = e; }

primary_expression <-
  e:identifier { $$ = e; }
## TODO: Strings ##
/ e:number { $$ = e; }
/ '(' _ e:expression _ ')' { $$ = e; }

identifier <-
  IDENT(IDENT/DEC)* { $$ = c_parser_ast_node_init_terminal(auxil, c_parser_ast_node_type_Identifier, c_parser_str_range_init($0s, $0e)); }

number <-
  DEC+ { $$ = c_parser_ast_node_init_terminal(auxil, c_parser_ast_node_type_Integer, c_parser_str_range_init($0s, $0e)); }
## TODO floats ##

## TODO keywords ##

DEC <- [0-9]
IDENT <- [a-zA-Z_]

_ <- ( whitespace / comment )*

comment <-
  '/*' ( !'*/' . )* '*/' { c_parser_handle_comment(auxil, c_parser_str_range_init($0s, $0e)); }
/ '/*' ( !'*/' . )* { c_parser_handle_error(auxil, c_parser_error_type_UnclosedComment, c_parser_str_range_init($0s, $0e)); }

whitespace <- ( blank / EOL )
blank <- [ \t\v\f]
EOL <- '\n' / '\r\n' / '\r'
EOF <- !.

%%
// Returns parse state after parsing source text.
c_parser_state c_parser_execute(char *source) {
  c_parser_state state = c_parser_state_init(source);
  c_parser_context_t *ctx = c_parser_create(&state);
  c_parser_ast_node *ast;
  int ret = c_parser_parse(ctx, &ast);
  state.programNode = ast;
  c_parser_destroy(ctx);
  if (ret) {
    state.isValid = false;
  }
  return state;
}