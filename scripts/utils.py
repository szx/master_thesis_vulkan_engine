import os
import sys
from pathlib import Path
import subprocess
import shlex
from configparser import ConfigParser, ExtendedInterpolation
import clang.cindex

script_path = Path(os.path.realpath(__file__))
root_path = script_path.parents[1]
src_path = root_path / 'src'
config_path = root_path / 'scripts' / 'config.txt'

def get_vulkan_sdk_path():
    vulkan_sdk_path = os.environ.get('VULKAN_SDK')
    assert (vulkan_sdk_path is not None)
    return vulkan_sdk_path

def get_header_paths():
    for dirname, dirnames, filenames in os.walk(src_path):
        if os.path.basename(dirname) == 'codegen':
            continue
        for filename in filenames:
            if filename.endswith('.h'):
                yield os.path.join(dirname, filename)


def get_relative_path(shorter, longer):
    return os.path.relpath(longer, shorter)


def get_output_path(filename):
    return os.path.join(src_path, 'codegen', filename)


def generate_strings(elements, template):
    for e in elements:
        yield template(e)


def output_strings(strings, path):
    with open(path, 'w') as f:
        f.write('/* This file was autogenerated. */\n\n')
        f.write('\n'.join(strings))
        f.write('\n')


def execute_command(command):
    process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE)
    output, error = process.communicate()
    return output, error


def parse_config():
    config = ConfigParser(interpolation=ExtendedInterpolation())
    config.optionxform = lambda value: value
    config.read(config_path)
    return config


def find_c_decls_in_str(string, cursor_kind):
    unique_decls = []

    def walk(node):
        if node.kind == cursor_kind and node.spelling != '':
            if not any([x.spelling == node.spelling for x in unique_decls]):
                unique_decls.append(node)
        for c in node.get_children():
            walk(c)

    index = clang.cindex.Index.create()
    walk(index.parse("temp.c", args=['-str=c11'], unsaved_files=[('temp.c', string)]).cursor)

    unique_decls.sort(key=lambda x: x.spelling)
    return unique_decls
