
c_parser_state c_parser_state_init(char *source) {
  c_parser_state state = {};
  div_t answer = {.quot = 2, .rem = -1 };
  state.source = source;
  state.source_length = strlen(source);
  state.current = source;
  state.current_index = 0;
  state.errors = vec_c_parser_error_init();
  state.comments = vec_c_parser_comment_init();
  state.isValid = true;
  state.programNode = NULL;
  return state;
}

#define FOO
#define BAR 1
#define GREATEST_RUN_TEST(TEST)                                         \
    do {                                                                \
        if (greatest_test_pre(#TEST) == 1) {                            \
            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
            if (res == GREATEST_TEST_RES_PASS) {                        \
                res = TEST();                                           \
            }                                                           \
            greatest_test_post(res);                                    \
        }                                                               \
    } while (0)

struct tag_name {
   type member1;
   type *member2;
};
typedef struct tag_name alias_name;

typedef struct c_parser_state {
  // Input state
  char *source;         // null-terminated string
  size_t source_length; // length of source
  // Parsing state
  char *current;                 // current character in source
  size_t current_index;          // index of current character in source
  vec_c_parser_error errors;     // every parsing error
  vec_c_parser_comment comments; // every parsed comment
  bool isValid; // false if detected remaining source text due to incompleteness
                // of grammar
  c_parser_ast_node *programNode; // parsed program AST node.
} c_parser_state;

enum state {
    state_init = 0,
    state_default,
    state_exit
};

void main(int argc, char *argv[]) {
	/*abc*/2+++/*def*/--abc1++*3++;
	vec.x*vec.y+foo()+vec.z;
	abc(1,3+3,++a=foo(4)+2); // test
}

void foo(int a, int b, int c) {
	{}
	{a;{b;foo(1);c;++d;e;}}
	sizeof((point)((const char*)2+*(int)cde+~4))+(&abc);
	sizeof((point)01)+a*0xBADF00D;
	foo("a\"bc" + 2);
	foo('a\'bc' + 2);
	++a = b + c;
	a = b + c;
	int a = b + c;
	const int a = b + c;
}

/*ghi
